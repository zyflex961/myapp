{"version":3,"file":"576.0a6e65dc8ff4c6b60dfa.js","mappings":"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","sources":["webpack://mytonwallet/./src/util/ledger/constants.ts","webpack://mytonwallet/./src/util/ledger/index.ts"],"sourcesContent":["export const DEVICE_DETECT_ATTEMPTS = 3;\r\nexport const PAUSE = 125;\r\nexport const ATTEMPTS = 10;\r\n","/*\r\n * This file must be imported dynamically via import().\r\n * This is needed to reduce the app size when Ledger is not used.\r\n *\r\n * This file is responsible only for common Ledger connection. Chain-specific logic is implemented in the API.\r\n */\r\n\r\nimport type Transport from '@ledgerhq/hw-transport';\r\nimport TransportWebHID from '@ledgerhq/hw-transport-webhid';\r\nimport TransportWebUSB from '@ledgerhq/hw-transport-webusb';\r\nimport type { HIDTransport } from '@mytonwallet/capacitor-usb-hid';\r\nimport type { ICapacitorUSBDevice } from '@mytonwallet/capacitor-usb-hid/dist/esm/definitions';\r\n\r\nimport type BleTransport from '../../lib/ledger-hw-transport-ble/BleTransport';\r\nimport type { LedgerTransport } from './types';\r\n\r\nimport { IS_CAPACITOR } from '../../config';\r\nimport { logDebug, logDebugError } from '../logs';\r\nimport { pause } from '../schedulers';\r\nimport { IS_ANDROID_APP } from '../windowEnvironment';\r\nimport { ATTEMPTS, DEVICE_DETECT_ATTEMPTS, PAUSE } from './constants';\r\n\r\ntype BleConnectorClass = typeof import('./bleConnector').BleConnector;\r\ntype HIDTransportClass = typeof import('@mytonwallet/capacitor-usb-hid/dist/esm').HIDTransport;\r\ntype ListLedgerDevicesFunction = typeof import('@mytonwallet/capacitor-usb-hid/dist/esm').listLedgerDevices;\r\n\r\nlet transport: TransportWebHID | TransportWebUSB | BleTransport | HIDTransport | undefined;\r\nlet transportSupport: {\r\n  hid: boolean;\r\n  webUsb: boolean;\r\n  bluetooth: boolean;\r\n} | undefined;\r\nlet currentLedgerTransport: LedgerTransport | undefined;\r\n\r\nlet hidImportPromise: Promise<{\r\n  transport: HIDTransportClass;\r\n  listLedgerDevices: ListLedgerDevicesFunction;\r\n}> | undefined;\r\nlet bleImportPromise: Promise<BleConnectorClass> | undefined;\r\nlet BleConnector: BleConnectorClass;\r\nlet MtwHidTransport: HIDTransportClass;\r\nlet listLedgerDevices: ListLedgerDevicesFunction;\r\n\r\nasync function ensureBleConnector() {\r\n  if (!IS_CAPACITOR) return undefined;\r\n\r\n  if (!bleImportPromise) {\r\n    bleImportPromise = import('./bleConnector').then((module) => {\r\n      return module.BleConnector;\r\n    });\r\n    BleConnector = await bleImportPromise;\r\n  }\r\n\r\n  return bleImportPromise;\r\n}\r\n\r\nasync function ensureHidTransport() {\r\n  if (!IS_ANDROID_APP) return undefined;\r\n\r\n  if (!hidImportPromise) {\r\n    hidImportPromise = import('@mytonwallet/capacitor-usb-hid/dist/esm').then((module) => {\r\n      return {\r\n        transport: module.HIDTransport,\r\n        listLedgerDevices: module.listLedgerDevices,\r\n      };\r\n    });\r\n    const result = await hidImportPromise;\r\n    MtwHidTransport = result.transport;\r\n    listLedgerDevices = result.listLedgerDevices;\r\n  }\r\n\r\n  return hidImportPromise;\r\n}\r\n\r\nvoid ensureBleConnector();\r\nvoid ensureHidTransport();\r\n\r\nexport async function detectAvailableTransports() {\r\n  await ensureBleConnector();\r\n  await ensureHidTransport();\r\n  const [hid, bluetooth, webUsb] = await Promise.all([\r\n    IS_ANDROID_APP ? MtwHidTransport.isSupported() : TransportWebHID.isSupported(),\r\n    BleConnector ? BleConnector.isSupported() : false,\r\n    TransportWebUSB.isSupported(),\r\n  ]);\r\n\r\n  logDebug('LEDGER TRANSPORTS', { hid, bluetooth, webUsb });\r\n\r\n  transportSupport = { hid, bluetooth, webUsb };\r\n\r\n  return {\r\n    isUsbAvailable: hid || webUsb,\r\n    isBluetoothAvailable: bluetooth,\r\n  };\r\n}\r\n\r\nexport async function hasUsbDevice() {\r\n  const support = await getTransportSupport();\r\n\r\n  if (support.hid) {\r\n    return IS_ANDROID_APP\r\n      ? await hasCapacitorHIDDevice()\r\n      : await hasWebHIDDevice();\r\n  }\r\n\r\n  if (support.webUsb) {\r\n    return await hasWebUsbDevice();\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nexport function openSystemBluetoothSettings() {\r\n  if (!BleConnector) return;\r\n  void BleConnector.openSettings();\r\n}\r\n\r\n/**\r\n * Connects the Ledger itself. To ensure the chain's Ledger app is ready, use the `waitForLedgerApp` API method.\r\n */\r\nexport async function connectLedger(preferredTransport?: LedgerTransport) {\r\n  const support = await getTransportSupport();\r\n\r\n  if (preferredTransport) currentLedgerTransport = preferredTransport;\r\n\r\n  // Note: if you call transport?.close() here, the Bluetooth transport won't work as expected. For example, if TON App\r\n  // is closed in the middle of an operation, the following operations will hang indefinitely.\r\n\r\n  try {\r\n    switch (currentLedgerTransport) {\r\n      case 'bluetooth':\r\n        transport = await connectBLE();\r\n        break;\r\n\r\n      case 'usb':\r\n      default:\r\n        if (support.hid) {\r\n          transport = await connectHID();\r\n        } else if (support.webUsb) {\r\n          transport = await connectWebUsb();\r\n        }\r\n        break;\r\n    }\r\n\r\n    if (!transport) {\r\n      logDebugError('connectLedger: BLE and/or HID are not supported');\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  } catch (err) {\r\n    logDebugError('connectLedger', err);\r\n    return false;\r\n  }\r\n}\r\n\r\nfunction connectHID() {\r\n  if (IS_ANDROID_APP) {\r\n    return connectCapacitorHID();\r\n  }\r\n\r\n  return connectWebHID();\r\n}\r\n\r\nasync function connectWebHID() {\r\n  for (let i = 0; i < ATTEMPTS; i++) {\r\n    const [device] = await TransportWebHID.list();\r\n\r\n    if (!device) {\r\n      await TransportWebHID.create();\r\n      await pause(PAUSE);\r\n      continue;\r\n    }\r\n\r\n    if (device.opened) {\r\n      return new TransportWebHID(device);\r\n    } else {\r\n      return TransportWebHID.open(device);\r\n    }\r\n  }\r\n\r\n  throw new Error('Failed to connect');\r\n}\r\n\r\nasync function connectWebUsb() {\r\n  for (let i = 0; i < ATTEMPTS; i++) {\r\n    const [device] = await TransportWebUSB.list();\r\n\r\n    if (!device) {\r\n      await TransportWebUSB.create();\r\n      await pause(PAUSE);\r\n      continue;\r\n    }\r\n\r\n    if (device.opened) {\r\n      return (await TransportWebUSB.openConnected()) ?? (await TransportWebUSB.request());\r\n    } else {\r\n      return TransportWebUSB.open(device);\r\n    }\r\n  }\r\n\r\n  throw new Error('Failed to connect');\r\n}\r\n\r\nasync function connectCapacitorHID(): Promise<HIDTransport> {\r\n  for (let i = 0; i < ATTEMPTS; i++) {\r\n    const [device] = await listLedgerDevices();\r\n\r\n    if (!device) {\r\n      await pause(PAUSE);\r\n      continue;\r\n    }\r\n\r\n    try {\r\n      return await Promise.race([\r\n        MtwHidTransport.open(device),\r\n        new Promise<never>((_, reject) => {\r\n          setTimeout(() => reject(new Error()), 1000);\r\n        }),\r\n      ]);\r\n    } catch (error) {\r\n      await pause(PAUSE);\r\n    }\r\n  }\r\n\r\n  throw new Error('Failed to connect');\r\n}\r\n\r\nasync function connectBLE(): Promise<BleTransport> {\r\n  if (!BleConnector) {\r\n    throw new Error('BLE is not supported on this device.');\r\n  }\r\n\r\n  const connection = await BleConnector.connect();\r\n  return connection.bleTransport;\r\n}\r\n\r\nasync function tryDetectDevice(\r\n  listDeviceFn: () => Promise<ICapacitorUSBDevice[]>,\r\n  createTransportFn?: () => Promise<unknown> | void,\r\n) {\r\n  try {\r\n    for (let i = 0; i < DEVICE_DETECT_ATTEMPTS; i++) {\r\n      const [device] = await listDeviceFn();\r\n      if (!device) {\r\n        if (createTransportFn) await createTransportFn();\r\n        await pause(PAUSE);\r\n        continue;\r\n      }\r\n\r\n      return true;\r\n    }\r\n  } catch (err: any) {\r\n    logDebugError('tryDetectDevice', err);\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nfunction hasWebHIDDevice() {\r\n  return tryDetectDevice(() => TransportWebHID.list(), () => TransportWebHID.create());\r\n}\r\nfunction hasWebUsbDevice() {\r\n  return tryDetectDevice(() => TransportWebUSB.list(), () => TransportWebUSB.create());\r\n}\r\nfunction hasCapacitorHIDDevice() {\r\n  return tryDetectDevice(listLedgerDevices);\r\n}\r\n\r\nasync function getTransportSupport() {\r\n  // Ensure transports support is detected lazily if missing\r\n  if (!transportSupport) {\r\n    await detectAvailableTransports();\r\n  }\r\n\r\n  return transportSupport!;\r\n}\r\n\r\nexport function getTransportOrFail(): Transport {\r\n  if (!transport) {\r\n    throw new Error('Ledger transport is not initialized'); // Run `connectLedger` to initialize\r\n  }\r\n  return transport;\r\n}\r\n"],"names":["DEVICE_DETECT_ATTEMPTS","PAUSE","ATTEMPTS","transport","transportSupport","currentLedgerTransport","hidImportPromise","bleImportPromise","BleConnector","MtwHidTransport","listLedgerDevices","async","ensureBleConnector","IS_CAPACITOR","then","module","ensureHidTransport","IS_ANDROID_APP","HIDTransport","result","detectAvailableTransports","hid","bluetooth","webUsb","Promise","all","isSupported","TransportWebHID","TransportWebUSB","logDebug","isUsbAvailable","isBluetoothAvailable","hasUsbDevice","support","getTransportSupport","tryDetectDevice","list","create","openSystemBluetoothSettings","openSettings","connectLedger","preferredTransport","Error","connect","bleTransport","connectBLE","i","device","race","open","_","reject","setTimeout","error","pause","connectCapacitorHID","opened","connectWebHID","openConnected","request","connectWebUsb","logDebugError","err","listDeviceFn","createTransportFn","getTransportOrFail"],"sourceRoot":""}