{"version":3,"file":"642.72a7b14cb4f2b49d3145.js","mappings":"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","sources":["webpack://mytonwallet/./src/lib/ledger-hw-transport-ble/monitorCharacteristic.ts","webpack://mytonwallet/./src/lib/ledger-hw-transport-ble/remapErrors.ts","webpack://mytonwallet/./src/lib/ledger-hw-transport-ble/BleTransport.ts","webpack://mytonwallet/./src/lib/ledger-hw-transport-ble/awaitsBleOn.ts","webpack://mytonwallet/./src/util/ledger/bleConnector.ts"],"sourcesContent":["import { BleClient } from '@capacitor-community/bluetooth-le';\r\nimport type { TraceContext } from '@ledgerhq/logs';\r\nimport { LocalTracer } from '@ledgerhq/logs';\r\nimport { Observable } from 'rxjs';\r\n\r\nimport type { Characteristic } from './types';\r\n\r\nconst LOG_TYPE = 'ble-verbose';\r\n\r\nexport const monitorCharacteristic = (\r\n  deviceId: string,\r\n  serviceId: string,\r\n  characteristic: Characteristic,\r\n  context?: TraceContext,\r\n): Observable<Buffer> => new Observable((o) => {\r\n  const tracer = new LocalTracer(LOG_TYPE, context);\r\n  tracer.trace('Start monitoring BLE characteristics', {\r\n    characteristicUuid: characteristic.uuid,\r\n  });\r\n\r\n  void BleClient.startNotifications(\r\n    deviceId,\r\n    serviceId,\r\n    characteristic.uuid,\r\n    (value) => {\r\n      const uint8Array = new Uint8Array(value.buffer);\r\n      const buffer = Buffer.from(uint8Array);\r\n      o.next(buffer);\r\n    },\r\n  );\r\n\r\n  return () => {\r\n    void BleClient.stopEnabledNotifications();\r\n  };\r\n});\r\n","import {\r\n  DisconnectedDevice,\r\n} from '@ledgerhq/errors';\r\n\r\nexport type IOBleErrorRemap = Error | null | undefined;\r\n\r\nexport const remapError = (error: IOBleErrorRemap): IOBleErrorRemap => {\r\n  if (!error || !error.message) return error;\r\n\r\n  if (error.message.includes('was disconnected') || error.message.includes('not found')) {\r\n    return new DisconnectedDevice();\r\n  }\r\n\r\n  return error;\r\n};\r\n\r\nexport const rethrowError = (e: Error | null | undefined): never => {\r\n  // throw remapError(e);\r\n  throw e ?? new Error();\r\n};\r\n\r\nexport const decoratePromiseErrors = <A>(promise: Promise<A>): Promise<A> => promise.catch(rethrowError);\r\n","/* eslint-disable @typescript-eslint/no-redundant-type-constituents */\r\nimport type { BleService } from '@capacitor-community/bluetooth-le';\r\nimport { BleClient, ConnectionPriority } from '@capacitor-community/bluetooth-le';\r\nimport type { BluetoothInfos, DeviceModel } from '@ledgerhq/devices';\r\nimport { DeviceModelId, getBluetoothServiceUuids, getInfosForServiceUuid } from '@ledgerhq/devices';\r\nimport { receiveAPDU } from '@ledgerhq/devices/lib/ble/receiveAPDU';\r\n// ---------------------------------------------------------------------------------------------\r\n// Since this is a react-native library and metro bundler does not support\r\n// package exports yet (see: https://github.com/facebook/metro/issues/670)\r\n// we need to import the file directly from the lib folder.\r\n// Otherwise it would force the consumer of the lib to manually \"tell\" metro to resolve to /lib.\r\n//\r\n// TLDR: /!\\ Do not remove the /lib part in the import statements below (@ledgerhq/devices/lib) ! /!\\\r\n// See: https://github.com/LedgerHQ/ledger-live/pull/879\r\nimport { sendAPDU } from '@ledgerhq/devices/lib/ble/sendAPDU';\r\nimport type { HwTransportError } from '@ledgerhq/errors';\r\nimport {\r\n  CantOpenDevice,\r\n  DisconnectedDeviceDuringOperation,\r\n  PairingFailed,\r\n  TransportError,\r\n  TransportExchangeTimeoutError,\r\n} from '@ledgerhq/errors';\r\nimport type { Observer as TransportObserver, Subscription as TransportSubscription } from '@ledgerhq/hw-transport';\r\nimport Transport from '@ledgerhq/hw-transport';\r\nimport type { TraceContext } from '@ledgerhq/logs';\r\nimport { LocalTracer, trace } from '@ledgerhq/logs';\r\nimport type { Observable, SchedulerLike } from 'rxjs';\r\nimport {\r\n  defer, firstValueFrom, from, merge, of, throwError, TimeoutError,\r\n} from 'rxjs';\r\nimport {\r\n  catchError, finalize, first, ignoreElements, map, share, tap, timeout,\r\n} from 'rxjs/operators';\r\nimport { v4 as uuid } from 'uuid';\r\nimport type { BleCharacteristic } from '@capacitor-community/bluetooth-le/dist/esm/definitions';\r\n\r\nimport type { IOBleErrorRemap } from './remapErrors';\r\nimport type { Characteristic, Device, ReconnectionConfig } from './types';\r\n\r\nimport { awaitsBleOn } from './awaitsBleOn';\r\nimport { monitorCharacteristic } from './monitorCharacteristic';\r\nimport { decoratePromiseErrors, remapError } from './remapErrors';\r\n\r\nconst LOG_TYPE = 'ble-verbose';\r\n\r\n/**\r\n * This is potentially not needed anymore, to be checked if the bug is still happening.\r\n */\r\nconst reconnectionConfig: ReconnectionConfig | null | undefined = {\r\n  pairingThreshold: 1000,\r\n  delayAfterFirstPairing: 4000,\r\n};\r\n\r\n// Allows us to give more granulary error messages\r\nconst bluetoothInfoCache: Record<string, BluetoothInfos> = {};\r\n\r\nfunction retrieveInfos(device: Device | null): BluetoothInfos | undefined {\r\n  if (!device || !device.uuids) return undefined;\r\n  const [serviceUUID] = device.uuids;\r\n  if (!serviceUUID) return undefined;\r\n  const infos = getInfosForServiceUuid(serviceUUID);\r\n  if (!infos) return undefined;\r\n\r\n  // If we retrieved information, update the cache\r\n  bluetoothInfoCache[device.deviceId] = infos;\r\n  return infos;\r\n}\r\n\r\nconst delay = (ms: number | undefined) => new Promise((success) => setTimeout(success, ms));\r\n\r\n/**\r\n * A cache of Bluetooth transport instances associated with device IDs.\r\n * Allows efficient storage and retrieval of previously initialized transports.\r\n * @type {Object.<string, BluetoothTransport>}\r\n */\r\nconst transportsCache: Record<string, BleTransport> = {};\r\n\r\n// `connectOptions` is actually used by `react-native-ble-plx` even if comment above `ConnectionOptions` says it's not used\r\nconst connectOptions: Record<string, unknown> = {\r\n  // 156 bytes to max the iOS < 10 limit (158 bytes)\r\n  // (185 bytes for iOS >= 10)(up to 512 bytes for Android, but could be blocked at 23 bytes)\r\n  requestMTU: 156,\r\n  // Priority 1 = high.\r\n  connectionPriority: 1,\r\n};\r\n\r\nconst clearDisconnectTimeout = (deviceId: string, context?: TraceContext): void => {\r\n  const cachedTransport = transportsCache[deviceId];\r\n  if (cachedTransport && cachedTransport.disconnectTimeout) {\r\n    trace({ type: LOG_TYPE, message: 'Clearing queued disconnect', context });\r\n    clearTimeout(cachedTransport.disconnectTimeout);\r\n  }\r\n};\r\n\r\nlet currentDeviceService: string | undefined;\r\n\r\n/**\r\n * React Native bluetooth BLE implementation\r\n * @example\r\n * import BleTransport from \"@ledgerhq/react-native-hw-transport-ble\";\r\n */\r\nexport default class BleTransport extends Transport {\r\n  static disconnectTimeoutMs = 5000;\r\n\r\n  static list = (): Promise<void[]> => {\r\n    throw new Error('not implemented');\r\n  };\r\n\r\n  /**\r\n   * Scan for bluetooth Ledger devices\r\n   * @param observer Device is partial in order to avoid the live-common/this dep\r\n   * @returns TransportSubscription\r\n   */\r\n  static listen(\r\n    observer: TransportObserver<any, HwTransportError>,\r\n  ): TransportSubscription {\r\n    let unsubscribed: boolean = false;\r\n    const tracer = new LocalTracer(LOG_TYPE);\r\n    tracer.trace('Listening for devices ...');\r\n\r\n    void BleClient.getConnectedDevices(getBluetoothServiceUuids()).then(async (devices) => {\r\n      if (unsubscribed) return;\r\n      for (const it of devices) {\r\n        observer.next({\r\n          type: 'add',\r\n          device: it,\r\n        });\r\n      }\r\n      await BleClient.stopLEScan();\r\n      void BleClient.requestLEScan({\r\n        services: getBluetoothServiceUuids(),\r\n      }, (result) => {\r\n        if (unsubscribed) return;\r\n        observer.next({\r\n          type: 'add',\r\n          device: result.device,\r\n        });\r\n      });\r\n    });\r\n\r\n    return {\r\n      unsubscribe: async () => {\r\n        unsubscribed = true;\r\n        await BleClient.stopLEScan();\r\n      },\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Opens a BLE transport\r\n   *\r\n   * @param {Device | string} deviceOrId\r\n   * @param timeoutMs Applied when trying to connect to a device\r\n   * @param context An optional context object for log/tracing strategy\r\n   * @param injectedDependencies Contains optional injected dependencies used by the transport implementation\r\n   *  - rxjsScheduler: dependency injected RxJS scheduler to control time. Default AsyncScheduler.\r\n   */\r\n  static async open(\r\n    deviceOrId: Device | string,\r\n    timeoutMs?: number,\r\n    context?: TraceContext,\r\n    { rxjsScheduler }: { rxjsScheduler?: SchedulerLike } = {},\r\n  ): Promise<BleTransport> {\r\n    return open(deviceOrId, true, timeoutMs, context, { rxjsScheduler });\r\n  }\r\n\r\n  /**\r\n   * Exposes method from the ble-plx library to disconnect a device\r\n   *\r\n   * Disconnects from {@link Device} if it's connected or cancels pending connection.\r\n   * A \"disconnect\" event will normally be emitted by the ble-plx lib once the device is disconnected.\r\n   * Errors are logged but silenced.\r\n   */\r\n  static disconnectDevice = async (id: string,\r\n    onDisconnect?: (e?: Error) => void,\r\n    context?: TraceContext): Promise<void> => {\r\n    const tracer = new LocalTracer(LOG_TYPE, context);\r\n    tracer.trace(`Trying to disconnect device ${id}`);\r\n\r\n    try {\r\n      await BleClient.disconnect(id);\r\n      onDisconnect?.();\r\n    } catch (error) {\r\n      // Only log, ignore if disconnect did not work\r\n      tracer\r\n        .withType('ble-error')\r\n        .trace('Error while trying to cancel device connection', { error });\r\n    }\r\n    tracer.trace(`Device ${id} disconnected`);\r\n  };\r\n\r\n  device: Device;\r\n\r\n  deviceModel: DeviceModel;\r\n\r\n  // eslint-disable-next-line no-null/no-null\r\n  disconnectTimeout: null | ReturnType<typeof setTimeout> = null;\r\n\r\n  id: string;\r\n\r\n  isConnected = true;\r\n\r\n  mtuSize = 20;\r\n\r\n  // Observable emitting data received from the device via BLE\r\n  notifyObservable: Observable<Buffer | Error>;\r\n\r\n  notYetDisconnected = true;\r\n\r\n  writableWithResponseCharacteristic: Characteristic;\r\n\r\n  writableWithoutResponseCharacteristic: Characteristic | undefined;\r\n\r\n  rxjsScheduler?: SchedulerLike;\r\n\r\n  // Transaction ids of communication operations that are currently pending\r\n  currentTransactionIds: Array<string>;\r\n\r\n  onDisconnect: ((error?: Error) => void) | undefined;\r\n\r\n  disconnectCallback: (() => void) | undefined;\r\n\r\n  /**\r\n   * The static `open` function is used to handle `BleTransport` instantiation\r\n   *\r\n   * @param device\r\n   * @param writableWithResponseCharacteristic A BLE characteristic that we can write on,\r\n   *   and that will be acknowledged in response from the device when it receives the written value.\r\n   * @param writableWithoutResponseCharacteristic A BLE characteristic that we can write on,\r\n   *   and that will not be acknowledged in response from the device\r\n   * @param notifyObservable A multicast observable that emits messages received from the device\r\n   * @param deviceModel\r\n   * @param params Contains optional options and injected dependencies used by the transport implementation\r\n   *  - abortTimeoutMs: stop the exchange after a given timeout. Another timeout exists\r\n   *    to detect unresponsive device (see `unresponsiveTimeout`). This timeout aborts the exchange.\r\n   *  - rxjsScheduler: dependency injected RxJS scheduler to control time. Default: AsyncScheduler.\r\n   */\r\n  constructor(\r\n    device: Device,\r\n    writableWithResponseCharacteristic: Characteristic,\r\n    writableWithoutResponseCharacteristic: Characteristic | undefined,\r\n    notifyObservable: Observable<Buffer | Error>,\r\n    deviceModel: DeviceModel,\r\n    { context, rxjsScheduler }: { context?: TraceContext; rxjsScheduler?: SchedulerLike } = {},\r\n  ) {\r\n    super({ context, logType: LOG_TYPE });\r\n    this.id = device.deviceId;\r\n    this.device = device;\r\n    this.writableWithResponseCharacteristic = writableWithResponseCharacteristic;\r\n    this.writableWithoutResponseCharacteristic = writableWithoutResponseCharacteristic;\r\n    this.notifyObservable = notifyObservable;\r\n    this.deviceModel = deviceModel;\r\n    this.rxjsScheduler = rxjsScheduler;\r\n    this.currentTransactionIds = [];\r\n\r\n    clearDisconnectTimeout(this.id);\r\n\r\n    this.tracer.trace(`New instance of BleTransport for device ${this.id}`);\r\n  }\r\n\r\n  /**\r\n   * A message exchange (APDU request <-> response) with the device that can be aborted.\r\n   *\r\n   * The message will be BLE-encoded/framed before being sent, and the response will be BLE-decoded.\r\n   *\r\n   * @param message A buffer (u8 array) of a none BLE-encoded message (an APDU for ex) to be sent to the device\r\n   *   as a request\r\n   * @param options Contains optional options for the exchange function\r\n   *  - abortTimeoutMs: stop the exchange after a given timeout. Another timeout exists\r\n   *    to detect unresponsive device (see `unresponsiveTimeout`). This timeout aborts the exchange.\r\n   * @returns A promise that resolves with the response data from the device.\r\n   */\r\n  exchange = (\r\n    message: Buffer,\r\n    { abortTimeoutMs }: { abortTimeoutMs?: number } = {},\r\n  ): Promise<Buffer> => {\r\n    if (this.exchangeBusyPromise) {\r\n      void BleTransport.disconnectDevice(this.id, this.onDisconnect);\r\n    }\r\n    const tracer = this.tracer.withUpdatedContext({\r\n      function: 'exchange',\r\n    });\r\n    tracer.trace('Exchanging APDU ...', { abortTimeoutMs });\r\n    tracer.withType('apdu').trace(`=> ${message.toString('hex')}`);\r\n\r\n    return this.exchangeAtomicImpl(() => {\r\n      return firstValueFrom(\r\n        // `sendApdu` will only emit if an error occurred, otherwise it will complete,\r\n        // while `receiveAPDU` will emit the full response.\r\n        // Consequently, it monitors the response while being able to reject on an error from the send.\r\n        merge(\r\n          this.notifyObservable.pipe((data) => receiveAPDU(data, { context: tracer.getContext() })),\r\n          sendAPDU(this.write, message, this.mtuSize, {\r\n            context: tracer.getContext(),\r\n          }),\r\n        ).pipe(\r\n          abortTimeoutMs ? timeout(abortTimeoutMs, this.rxjsScheduler) : tap(),\r\n          tap((data) => {\r\n            tracer.withType('apdu').trace(`<= ${data.toString('hex')}`);\r\n          }),\r\n          catchError(async (error) => {\r\n            // Currently only 1 reason the exchange has been explicitly aborted (other than job and transport errors): a timeout\r\n            if (error instanceof TimeoutError) {\r\n              tracer.trace(\r\n                'Aborting due to timeout and trying to cancel all communication write of the current exchange',\r\n                {\r\n                  abortTimeoutMs,\r\n                  transactionIds: this.currentTransactionIds,\r\n                },\r\n              );\r\n\r\n              // No concurrent exchange should happen at the same time, so all pending operations are part of the same exchange\r\n              await this.cancelPendingOperations();\r\n\r\n              throw new TransportExchangeTimeoutError('Exchange aborted due to timeout');\r\n            }\r\n\r\n            tracer.withType('ble-error').trace('Error while exchanging APDU', { error });\r\n\r\n            if (this.notYetDisconnected) {\r\n              // In such case we will always disconnect because something is bad.\r\n              // This sends a `disconnect` event.\r\n              await BleTransport.disconnectDevice(this.id, this.onDisconnect);\r\n            }\r\n\r\n            const mappedError = remapError(error as IOBleErrorRemap);\r\n            tracer.trace('Error while exchanging APDU, mapped and throws following error', {\r\n              mappedError,\r\n            });\r\n            // eslint-disable-next-line @typescript-eslint/only-throw-error\r\n            throw mappedError;\r\n          }),\r\n          finalize(() => {\r\n            tracer.trace('Clearing current transaction ids', {\r\n              currentTransactionIds: this.currentTransactionIds,\r\n            });\r\n            this.clearCurrentTransactionIds();\r\n          }),\r\n        ),\r\n      );\r\n    });\r\n  };\r\n\r\n  private async cancelPendingOperations() {\r\n    // BleTransport does not support cancellation\r\n    await BleTransport.disconnectDevice(this.id, this.onDisconnect);\r\n  }\r\n\r\n  /**\r\n   * Sets the collection of current transaction ids to an empty array\r\n   */\r\n  private clearCurrentTransactionIds() {\r\n    this.currentTransactionIds = [];\r\n  }\r\n\r\n  /**\r\n   * Negotiate with the device the maximum transfer unit for the ble frames\r\n   * @returns Promise<number>\r\n   */\r\n  async inferMTU(): Promise<number> {\r\n    let mtu = (await BleClient.getMtu(this.device.deviceId));\r\n    this.tracer.trace('Inferring MTU ...', { currentDeviceMtu: mtu });\r\n\r\n    await this.exchangeAtomicImpl(async () => {\r\n      try {\r\n        mtu = await firstValueFrom(\r\n          merge(\r\n            this.notifyObservable.pipe(\r\n              map((maybeError) => {\r\n                // Catches the `PairingFailed` Error that has only been emitted\r\n                if (maybeError instanceof Error) {\r\n                  throw maybeError;\r\n                }\r\n\r\n                return maybeError;\r\n              }),\r\n              first((buffer) => buffer.readUInt8(0) === 0x08),\r\n              map((buffer) => buffer.readUInt8(5)),\r\n            ),\r\n            defer(() => from(this.write(Buffer.from([0x08, 0, 0, 0, 0])))).pipe(ignoreElements()),\r\n          ),\r\n        );\r\n      } catch (error: any) {\r\n        this.tracer.withType('ble-error').trace('Error while inferring MTU', { mtu });\r\n\r\n        await BleTransport.disconnectDevice(this.id, this.onDisconnect);\r\n\r\n        const mappedError = remapError(error);\r\n        this.tracer.trace('Error while inferring APDU, mapped and throws following error', {\r\n          mappedError,\r\n        });\r\n        // eslint-disable-next-line @typescript-eslint/only-throw-error\r\n        throw mappedError;\r\n      } finally {\r\n        // When negotiating the MTU, a message is sent/written to the device, and a transaction id was associated to this write\r\n        this.clearCurrentTransactionIds();\r\n      }\r\n    });\r\n\r\n    this.tracer.trace('Successfully negotiated MTU with device', {\r\n      mtu,\r\n      mtuSize: this.mtuSize,\r\n    });\r\n    if (mtu > 20) {\r\n      this.mtuSize = mtu;\r\n    }\r\n\r\n    return this.mtuSize;\r\n  }\r\n\r\n  /**\r\n   * Exposed method from the ble-plx library.\r\n   * Request the connection priority for the given device.\r\n   * @returns {Promise<void>}\r\n   * @param connectionPriority\r\n   */\r\n  async requestConnectionPriority(\r\n    connectionPriority: 'Balanced' | 'High' | 'LowPower',\r\n  ): Promise<void> {\r\n    let connectionPriorityMapped: ConnectionPriority;\r\n    switch (connectionPriority) {\r\n      case 'High':\r\n        connectionPriorityMapped = ConnectionPriority.CONNECTION_PRIORITY_BALANCED;\r\n        break;\r\n      case 'LowPower':\r\n        connectionPriorityMapped = ConnectionPriority.CONNECTION_PRIORITY_LOW_POWER;\r\n        break;\r\n      case 'Balanced':\r\n        connectionPriorityMapped = ConnectionPriority.CONNECTION_PRIORITY_BALANCED;\r\n        break;\r\n    }\r\n    await decoratePromiseErrors(\r\n      BleClient.requestConnectionPriority(this.device.deviceId, connectionPriorityMapped),\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Do not call this directly unless you know what you're doing. Communication\r\n   * with a Ledger device should be through the {@link exchange} method.\r\n   *\r\n   * For each call a transaction id is added to the current stack of transaction ids.\r\n   * With this transaction id, a pending BLE communication operations can be cancelled.\r\n   * Note: each frame/packet of a longer BLE-encoded message to be sent should have their unique transaction id.\r\n   *\r\n   * @param buffer BLE-encoded packet to send to the device\r\n   * @param frameId Frame id to make `write` aware of a bigger message that this frame/packet is part of.\r\n   *  Helps to create related a collection of transaction ids\r\n   */\r\n  write = async (buffer: Buffer): Promise<void> => {\r\n    const transactionId = uuid();\r\n    this.currentTransactionIds.push(transactionId);\r\n\r\n    const tracer = this.tracer.withUpdatedContext({ transactionId });\r\n    tracer.trace('Writing to device', {\r\n      willMessageBeAcked: !this.writableWithoutResponseCharacteristic,\r\n    });\r\n\r\n    try {\r\n      const uint8Array = new Uint8Array(buffer);\r\n      const dataView = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);\r\n      await BleClient.write(\r\n        this.device.deviceId,\r\n        currentDeviceService!,\r\n        this.writableWithResponseCharacteristic.uuid,\r\n        dataView,\r\n      );\r\n      tracer.withType('ble-frame').trace(`=> ${buffer.toString('hex')}`);\r\n    } catch (error: unknown) {\r\n      tracer.trace('Error while writing APDU', { error });\r\n      throw new DisconnectedDeviceDuringOperation(\r\n        error instanceof Error ? error.message : `${String(error)}`,\r\n      );\r\n    }\r\n  };\r\n\r\n  /**\r\n   * We intentionally do not immediately close a transport connection.\r\n   * Instead, we queue the disconnect and wait for a future connection to dismiss the event.\r\n   * This approach prevents unnecessary disconnects and reconnects. We use the isConnected\r\n   * flag to ensure that we do not trigger a disconnect if the current cached transport has\r\n   * already been disconnected.\r\n   * @returns {Promise<void>}\r\n   */\r\n  async close(): Promise<void> {\r\n    const tracer = this.tracer.withUpdatedContext({ function: 'close' });\r\n    tracer.trace('Closing, queuing a disconnect with a timeout ...');\r\n\r\n    let resolve: (value: void | PromiseLike<void>) => void;\r\n    const disconnectPromise = new Promise<void>((innerResolve) => {\r\n      resolve = innerResolve;\r\n    });\r\n\r\n    clearDisconnectTimeout(this.id);\r\n\r\n    this.disconnectTimeout = setTimeout(() => {\r\n      tracer.trace('Disconnect timeout has been reached ...');\r\n      if (this.isConnected) {\r\n        BleTransport.disconnectDevice(this.id, this.onDisconnect, tracer.getContext())\r\n          .catch(() => {})\r\n          .finally(resolve);\r\n      } else {\r\n        resolve();\r\n      }\r\n    }, BleTransport.disconnectTimeoutMs);\r\n\r\n    // The closure will occur no later than 5s, triggered either by disconnection\r\n    // or the actual response of the apdu.\r\n    await Promise.race([this.exchangeBusyPromise || Promise.resolve(), disconnectPromise]);\r\n  }\r\n}\r\n\r\n/**\r\n * Opens a BLE connection with a given device. Returns a Transport instance.\r\n *\r\n * @param deviceOrId\r\n * @param needsReconnect\r\n * @param timeoutMs Optional Timeout (in ms) applied during the connection with the device\r\n * @param context Optional tracing/log context\r\n * @param injectedDependencies Contains optional injected dependencies used by the transport implementation\r\n *  - rxjsScheduler: dependency injected RxJS scheduler to control time. Default AsyncScheduler.\r\n * @returns A BleTransport instance\r\n */\r\nasync function open(\r\n  deviceOrId: Device | string,\r\n  needsReconnect: boolean,\r\n  timeoutMs?: number,\r\n  context?: TraceContext,\r\n  { rxjsScheduler }: { rxjsScheduler?: SchedulerLike } = {},\r\n) {\r\n  const tracer = new LocalTracer(LOG_TYPE, context);\r\n  let device: Device;\r\n  tracer.trace(`Opening ${typeof deviceOrId === 'string' ? deviceOrId : deviceOrId.deviceId}`, { needsReconnect });\r\n  let deviceId: string;\r\n  // eslint-disable-next-line prefer-const\r\n  let transport: BleTransport;\r\n\r\n  if (typeof deviceOrId === 'string') {\r\n    deviceId = deviceOrId;\r\n    if (transportsCache[deviceOrId]) {\r\n      tracer.trace('Transport in cache, using it');\r\n      clearDisconnectTimeout(deviceOrId);\r\n\r\n      // The cached transport probably has an older trace/log context\r\n      transportsCache[deviceOrId].setTraceContext(context);\r\n      return transportsCache[deviceOrId];\r\n    }\r\n\r\n    tracer.trace(`Trying to open device: ${deviceOrId}`);\r\n    await awaitsBleOn();\r\n\r\n    // Returns a list of known devices by their identifiers\r\n    const devices = (await BleClient.getDevices([deviceOrId]));\r\n    tracer.trace(`Found ${devices.length} already known device(s) with given id`, { deviceOrId });\r\n    [device] = devices;\r\n\r\n    if (!device) {\r\n      // Returns a list of the peripherals currently connected to the system\r\n      // which have discovered services, connected to system doesn't mean\r\n      // connected to our app, we check that below.\r\n      const services = (await BleClient.getServices(deviceOrId)).map((it) => it.uuid);\r\n      const connectedDevices = (await BleClient.getConnectedDevices(services));\r\n      const connectedDevicesFiltered = connectedDevices.filter((d) => d.deviceId === deviceOrId);\r\n      tracer.trace(\r\n        `No known device with given id.\r\n        Found ${connectedDevicesFiltered.length} devices from already connected devices`,\r\n        { deviceOrId },\r\n      );\r\n      [device] = connectedDevicesFiltered;\r\n    }\r\n\r\n    if (!device) {\r\n      // We still don't have a device, so we attempt to connect to it.\r\n      tracer.trace('No known nor connected devices with given id. Trying to connect to device', {\r\n        deviceOrId,\r\n        timeoutMs,\r\n      });\r\n\r\n      // Nb ConnectionOptions dropped since it's not used internally by ble-plx.\r\n      try {\r\n        await BleClient.connect(deviceOrId, () => {\r\n          transport.onDisconnect?.();\r\n        }, {\r\n          timeout: timeoutMs,\r\n        });\r\n      } catch (e: any) {\r\n        tracer.trace(`Error code: ${e.errorCode}`);\r\n        throw e;\r\n      }\r\n    }\r\n\r\n    if (!device) {\r\n      throw new CantOpenDevice();\r\n    }\r\n  } else {\r\n    // It was already a Device\r\n    device = deviceOrId;\r\n    deviceId = deviceOrId.deviceId;\r\n  }\r\n\r\n  const connectedDevices = await BleClient.getConnectedDevices(getBluetoothServiceUuids());\r\n\r\n  if (!connectedDevices.find((it) => it.deviceId === deviceId)) {\r\n    tracer.trace('Device found but not connected. connecting...', { timeoutMs, connectOptions });\r\n    try {\r\n      await BleClient.connect(deviceId, () => {\r\n        transport.onDisconnect?.();\r\n      }, {\r\n        timeout: timeoutMs,\r\n      });\r\n    } catch (error: any) {\r\n      tracer.trace('Connect error', { error });\r\n      // eslint-disable-next-line @typescript-eslint/only-throw-error\r\n      throw remapError(error);\r\n    }\r\n  }\r\n\r\n  tracer.trace('Device is connected now, getting services and characteristics');\r\n\r\n  let services: BleService[] = [];\r\n\r\n  await BleClient.discoverServices(deviceId);\r\n  services = (await BleClient.getServices(deviceId));\r\n\r\n  let res: BluetoothInfos | undefined = retrieveInfos(device);\r\n  const characteristics: BleCharacteristic[] = [];\r\n\r\n  if (!res) {\r\n    for (const serviceUUID of getBluetoothServiceUuids()) {\r\n      try {\r\n        const deviceService = services.find((it) => it.uuid === serviceUUID);\r\n        res = getInfosForServiceUuid(serviceUUID);\r\n        if (res && deviceService) {\r\n          characteristics.push(...deviceService.characteristics);\r\n          currentDeviceService = res.serviceUuid;\r\n          break;\r\n        }\r\n      } catch (e) {\r\n        // Attempt to connect to the next service\r\n      }\r\n    }\r\n  }\r\n\r\n  if (!res) {\r\n    tracer.trace('Service not found');\r\n    throw new TransportError('service not found', 'BLEServiceNotFound');\r\n  }\r\n\r\n  const {\r\n    deviceModel, writeUuid, writeCmdUuid, notifyUuid,\r\n  } = res;\r\n\r\n  /* if (!characteristics) {\r\n    characteristics = await device.characteristicsForService(serviceUuid);\r\n  } */\r\n\r\n  if (!characteristics) {\r\n    tracer.trace('Characteristics not found');\r\n    throw new TransportError('service not found', 'BLEServiceNotFound');\r\n  }\r\n\r\n  let writableWithResponseCharacteristic: Characteristic | null | undefined;\r\n  let writableWithoutResponseCharacteristic: Characteristic | undefined;\r\n  // A characteristic that can monitor value changes\r\n  let notifiableCharacteristic: Characteristic | null | undefined;\r\n\r\n  for (const c of characteristics) {\r\n    if (c.uuid === writeUuid) {\r\n      writableWithResponseCharacteristic = c;\r\n    } else if (c.uuid === writeCmdUuid) {\r\n      writableWithoutResponseCharacteristic = c;\r\n    } else if (c.uuid === notifyUuid) {\r\n      notifiableCharacteristic = c;\r\n    }\r\n  }\r\n\r\n  if (!writableWithResponseCharacteristic) {\r\n    throw new TransportError('write characteristic not found', 'BLECharacteristicNotFound');\r\n  }\r\n\r\n  if (!notifiableCharacteristic) {\r\n    throw new TransportError('notify characteristic not found', 'BLECharacteristicNotFound');\r\n  }\r\n\r\n  if (!writableWithResponseCharacteristic.properties.write) {\r\n    throw new TransportError(\r\n      'The writable-with-response characteristic is not writable with response',\r\n      'BLECharacteristicInvalid',\r\n    );\r\n  }\r\n\r\n  if (!notifiableCharacteristic.properties.notify) {\r\n    throw new TransportError('notify characteristic not notifiable', 'BLECharacteristicInvalid');\r\n  }\r\n\r\n  if (writableWithoutResponseCharacteristic) {\r\n    if (!writableWithoutResponseCharacteristic.properties.writeWithoutResponse) {\r\n      throw new TransportError(\r\n        'The writable-without-response characteristic is not writable without response',\r\n        'BLECharacteristicInvalid',\r\n      );\r\n    }\r\n  }\r\n\r\n  const deviceMtu = await BleClient.getMtu(device.deviceId);\r\n  tracer.trace(`device.mtu=${deviceMtu}`);\r\n\r\n  // Inits the observable that will emit received data from the device via BLE\r\n  const notifyObservable = monitorCharacteristic(deviceId,\r\n    currentDeviceService!,\r\n    notifiableCharacteristic,\r\n    context).pipe(\r\n    catchError((e) => {\r\n      // LL-9033 fw 2.0.2 introduced this case, we silence the inner unhandled error.\r\n      // It will be handled when negotiating the MTU in `inferMTU` but will be ignored in other cases.\r\n      const msg = String(e);\r\n      return msg.includes('notify change failed')\r\n        ? of(new PairingFailed(msg))\r\n        : throwError(() => e);\r\n    }),\r\n    tap((value) => {\r\n      if (value instanceof PairingFailed) return;\r\n      trace({ type: 'ble-frame', message: `<= ${value.toString('hex')}`, context });\r\n    }),\r\n    // Returns a new Observable that multicasts (shares) the original Observable.\r\n    // As long as there is at least one Subscriber this Observable will be subscribed and emitting data.\r\n    share(),\r\n  );\r\n\r\n  // Keeps the input from the device observable alive (multicast observable)\r\n  const notif = notifyObservable.subscribe();\r\n\r\n  transport = new BleTransport(\r\n    device,\r\n    writableWithResponseCharacteristic,\r\n    writableWithoutResponseCharacteristic,\r\n    notifyObservable,\r\n    deviceModel,\r\n    {\r\n      context,\r\n      rxjsScheduler,\r\n    },\r\n  );\r\n  tracer.trace('New BleTransport created');\r\n\r\n  // Keeping it as a comment for now but if no new bluetooth issues occur, we will be able to remove it\r\n  // await transport.requestConnectionPriority(\"High\");\r\n\r\n  // let disconnectedSub: Subscription;\r\n\r\n  // Callbacks on `react-native-ble-plx` notifying the device has been disconnected\r\n  transport.onDisconnect = (error?: Error) => {\r\n    transport.isConnected = false;\r\n    transport.notYetDisconnected = false;\r\n    notif.unsubscribe();\r\n    // disconnectedSub?.remove();\r\n\r\n    clearDisconnectTimeout(transport.id);\r\n    delete transportsCache[transport.id];\r\n    tracer.trace(\r\n      `On device disconnected callback: cleared cached transport for ${transport.id},\r\n      emitting Transport event \"disconnect. Error: ${error}\"`,\r\n      { reason: error },\r\n    );\r\n    transport.emit('disconnect', error);\r\n    transport.disconnectCallback?.();\r\n  };\r\n\r\n  transportsCache[transport.id] = transport;\r\n  const beforeMTUTime = Date.now();\r\n\r\n  /* disconnectedSub = device.onDisconnected((e) => {\r\n    if (!transport.notYetDisconnected) return;\r\n    onDisconnect(e);\r\n  }); */\r\n\r\n  try {\r\n    await transport.inferMTU();\r\n  } finally {\r\n    const afterMTUTime = Date.now();\r\n\r\n    if (reconnectionConfig) {\r\n      // Refer to ledgerjs archived repo issue #279.\r\n      // All HW .v1 LNX have a bug that prevents us from communicating with the device right after pairing.\r\n      // When we connect for the first time we issue a disconnect and reconnect, this guarantees that we are\r\n      // in a good state. This is avoidable in some key scenarios â†“\r\n      if (afterMTUTime - beforeMTUTime < reconnectionConfig.pairingThreshold) {\r\n        needsReconnect = false;\r\n      } else if (deviceModel.id === DeviceModelId.stax) {\r\n        tracer.trace('Skipping \"needsReconnect\" strategy for Stax');\r\n        needsReconnect = false;\r\n      }\r\n\r\n      if (needsReconnect) {\r\n        tracer.trace('Device needs reconnection. Triggering a disconnect');\r\n        await BleTransport.disconnectDevice(transport.id, transport.onDisconnect);\r\n        await delay(reconnectionConfig.delayAfterFirstPairing);\r\n      }\r\n    } else {\r\n      needsReconnect = false;\r\n    }\r\n  }\r\n\r\n  if (needsReconnect) {\r\n    tracer.trace('Reconnecting');\r\n    return open(device, false, timeoutMs, context);\r\n  }\r\n\r\n  return transport;\r\n}\r\n","import { BluetoothLe } from '@capacitor-community/bluetooth-le';\r\nimport { BluetoothRequired } from '@ledgerhq/errors';\r\n\r\nexport async function awaitsBleOn(): Promise<void> {\r\n  await BluetoothLe.initialize();\r\n  const isEnabled = await BluetoothLe.isEnabled();\r\n  if (!isEnabled) {\r\n    throw new BluetoothRequired('', {\r\n      state: 'disable',\r\n    });\r\n  }\r\n}\r\n","import { BleClient } from '@capacitor-community/bluetooth-le';\r\nimport type { Subscription as TransportSubscription } from '@ledgerhq/hw-transport';\r\nimport { v4 as uuid } from 'uuid';\r\nimport type { BleDevice } from '@capacitor-community/bluetooth-le/dist/esm/definitions';\r\n\r\nimport { IS_CAPACITOR } from '../../config';\r\nimport BleTransport from '../../lib/ledger-hw-transport-ble/BleTransport';\r\nimport { logDebug, logDebugError } from '../logs';\r\nimport { pause } from '../schedulers';\r\nimport { IS_ANDROID, IS_IOS } from '../windowEnvironment';\r\nimport { DEVICE_DETECT_ATTEMPTS, PAUSE } from './constants';\r\n\r\ninterface ScannedDevice {\r\n  identifier: string;\r\n  device: BleDevice;\r\n}\r\n\r\nexport interface LedgerConnection {\r\n  device: BleDevice;\r\n  bleTransport: BleTransport;\r\n}\r\n\r\nlet isBleInitialized = false;\r\nlet bleInitializationPromise: Promise<void> | undefined;\r\n\r\nlet listeningSubscription: TransportSubscription | undefined;\r\n\r\nlet scannedDevices: ScannedDevice[] = [];\r\nlet pairedDevice: LedgerConnection | undefined;\r\nlet onLedgerConnected: ((connection: LedgerConnection) => void) | undefined;\r\n\r\nfunction isConnecting() {\r\n  return !!listeningSubscription;\r\n}\r\n\r\nfunction scannedDeviceIsValidYet(scannedDevice: ScannedDevice): boolean {\r\n  if (!scannedDevices.find((it) => it.identifier === scannedDevice.identifier)) {\r\n    // List is already cleared\r\n    return false;\r\n  }\r\n\r\n  // A device is already paired\r\n  return !pairedDevice;\r\n}\r\n\r\nasync function tryConnectingLedgerDevice(scannedDevice: ScannedDevice) {\r\n  try {\r\n    // Check if stopped before retry\r\n    if (!scannedDeviceIsValidYet(scannedDevice)) return;\r\n\r\n    const bleTransport = await BleTransport.open(scannedDevice.device);\r\n    // Check if stopped before connection establish\r\n    if (!scannedDeviceIsValidYet(scannedDevice)) return;\r\n\r\n    const ledgerConnection = {\r\n      device: scannedDevice.device,\r\n      bleTransport,\r\n    };\r\n    pairedDevice = ledgerConnection;\r\n\r\n    bleTransport.disconnectCallback = () => {\r\n      pairedDevice = undefined;\r\n      if (isConnecting()) {\r\n        stop();\r\n        void start();\r\n      }\r\n    };\r\n\r\n    setTimeout(() => {\r\n      // Make sure not disconnected yet\r\n      if (pairedDevice?.device.deviceId === ledgerConnection.device.deviceId) {\r\n        onLedgerConnected?.(ledgerConnection);\r\n        stop();\r\n      } else if (isConnecting()) {\r\n        // Unexpectedly, disconnected before calling the callback, restart!\r\n        pairedDevice = undefined;\r\n        stop();\r\n        void start();\r\n      }\r\n    }, 1000);\r\n  } catch (error) {\r\n    setTimeout(() => {\r\n      void tryConnectingLedgerDevice(scannedDevice);\r\n    }, 10000);\r\n  }\r\n}\r\n\r\nasync function isSupported() {\r\n  if (!IS_CAPACITOR) return false;\r\n\r\n  let isEnabled = false;\r\n  try {\r\n    await ensureBleInitialized();\r\n    if (IS_ANDROID) {\r\n      await BleClient.requestEnable();\r\n    }\r\n\r\n    isEnabled = await BleClient.isEnabled();\r\n    logDebug('BLE isSupported result', { isEnabled });\r\n  } catch (err: any) {\r\n    logDebugError('Error while checking BLE availability', err);\r\n  }\r\n\r\n  return isEnabled;\r\n}\r\n\r\nasync function start() {\r\n  await ensureBleInitialized();\r\n\r\n  listeningSubscription = BleTransport.listen({\r\n    next: (event: { type: string; device?: BleDevice }) => {\r\n      switch (event.type) {\r\n        case 'add':\r\n          if (event.device) {\r\n            if (!event.device.name) return;\r\n            if (scannedDevices.find((it) => it.device.deviceId === event.device?.deviceId)) return;\r\n            const scannedDevice = { identifier: uuid(), device: event.device };\r\n            scannedDevices.push(scannedDevice);\r\n            void tryConnectingLedgerDevice(scannedDevice);\r\n          }\r\n          break;\r\n      }\r\n    },\r\n    error: () => {\r\n      stop();\r\n    },\r\n    complete: () => {\r\n      stop();\r\n    },\r\n  });\r\n}\r\n\r\nfunction stop() {\r\n  scannedDevices = [];\r\n  listeningSubscription?.unsubscribe();\r\n  listeningSubscription = undefined;\r\n}\r\n\r\nfunction connect(): Promise<LedgerConnection> {\r\n  return new Promise((resolve) => {\r\n    onLedgerConnected = resolve;\r\n    if (pairedDevice) {\r\n      onLedgerConnected(pairedDevice);\r\n      return;\r\n    }\r\n\r\n    if (isConnecting()) return;\r\n    void start();\r\n  });\r\n}\r\n\r\nasync function openSettings() {\r\n  if (IS_ANDROID) {\r\n    await BleClient.openBluetoothSettings();\r\n  } else if (IS_IOS) {\r\n    await BleClient.openAppSettings();\r\n  }\r\n}\r\n\r\nexport const BleConnector = {\r\n  isSupported,\r\n  connect,\r\n  stop,\r\n  openSettings,\r\n};\r\n\r\nasync function ensureBleInitialized(): Promise<void> {\r\n  if (isBleInitialized) return;\r\n  if (bleInitializationPromise) return bleInitializationPromise;\r\n\r\n  bleInitializationPromise = (async () => {\r\n    let attempt = 0;\r\n    let lastError: Error | undefined;\r\n\r\n    while (attempt < DEVICE_DETECT_ATTEMPTS && !isBleInitialized) {\r\n      try {\r\n        await BleClient.initialize({\r\n          androidNeverForLocation: true,\r\n        });\r\n        isBleInitialized = true;\r\n        return;\r\n      } catch (err: any) {\r\n        lastError = err;\r\n\r\n        logDebugError('BLE initialize attempt failed', err);\r\n        await pause(PAUSE * attempt);\r\n      }\r\n\r\n      attempt += 1;\r\n    }\r\n\r\n    if (!isBleInitialized) {\r\n      throw lastError ?? new Error('BLE initialize failed');\r\n    }\r\n  })()\r\n    .finally(() => {\r\n      bleInitializationPromise = undefined;\r\n    });\r\n\r\n  return bleInitializationPromise;\r\n}\r\n"],"names":["remapError","error","message","includes","DisconnectedDevice","rethrowError","e","Error","LOG_TYPE","reconnectionConfig","pairingThreshold","delayAfterFirstPairing","bluetoothInfoCache","transportsCache","connectOptions","requestMTU","connectionPriority","clearDisconnectTimeout","deviceId","context","cachedTransport","disconnectTimeout","trace","type","clearTimeout","currentDeviceService","BleTransport","Transport","static","list","listen","observer","unsubscribed","LocalTracer","BleClient","getConnectedDevices","getBluetoothServiceUuids","then","async","it","devices","next","device","stopLEScan","requestLEScan","services","result","unsubscribe","open","deviceOrId","timeoutMs","rxjsScheduler","arguments","length","undefined","id","onDisconnect","tracer","disconnect","withType","deviceModel","isConnected","mtuSize","notifyObservable","notYetDisconnected","writableWithResponseCharacteristic","writableWithoutResponseCharacteristic","currentTransactionIds","disconnectCallback","constructor","super","logType","this","exchange","_this","abortTimeoutMs","exchangeBusyPromise","disconnectDevice","withUpdatedContext","function","toString","exchangeAtomicImpl","firstValueFrom","merge","pipe","data","receiveAPDU","getContext","sendAPDU","write","timeout","tap","catchError","TimeoutError","transactionIds","cancelPendingOperations","TransportExchangeTimeoutError","mappedError","finalize","clearCurrentTransactionIds","inferMTU","mtu","getMtu","currentDeviceMtu","map","maybeError","first","buffer","readUInt8","defer","from","Buffer","ignoreElements","requestConnectionPriority","connectionPriorityMapped","ConnectionPriority","CONNECTION_PRIORITY_BALANCED","CONNECTION_PRIORITY_LOW_POWER","promise","catch","transactionId","uuid","push","willMessageBeAcked","uint8Array","Uint8Array","dataView","DataView","byteOffset","byteLength","DisconnectedDeviceDuringOperation","String","close","resolve","disconnectPromise","Promise","innerResolve","setTimeout","finally","disconnectTimeoutMs","race","needsReconnect","transport","setTraceContext","BluetoothLe","initialize","isEnabled","BluetoothRequired","state","awaitsBleOn","getDevices","getServices","connectedDevicesFiltered","filter","d","connect","_transport$onDisconne","_transport","call","errorCode","CantOpenDevice","find","_transport$onDisconne2","_transport2","discoverServices","res","uuids","serviceUUID","infos","getInfosForServiceUuid","retrieveInfos","characteristics","deviceService","serviceUuid","TransportError","writeUuid","writeCmdUuid","notifyUuid","notifiableCharacteristic","c","properties","notify","writeWithoutResponse","deviceMtu","monitorCharacteristic","serviceId","characteristic","Observable","o","characteristicUuid","startNotifications","value","stopEnabledNotifications","msg","of","PairingFailed","throwError","share","notif","subscribe","_transport$disconnect","_transport3","reason","emit","beforeMTUTime","Date","now","afterMTUTime","DeviceModelId","stax","ms","success","bleInitializationPromise","listeningSubscription","pairedDevice","onLedgerConnected","isBleInitialized","scannedDevices","isConnecting","scannedDeviceIsValidYet","scannedDevice","identifier","tryConnectingLedgerDevice","bleTransport","ledgerConnection","stop","start","_pairedDevice","_onLedgerConnected","ensureBleInitialized","event","name","_event$device","complete","_listeningSubscriptio","BleConnector","isSupported","IS_CAPACITOR","IS_ANDROID","requestEnable","logDebug","err","logDebugError","openSettings","openBluetoothSettings","IS_IOS","openAppSettings","lastError","attempt","DEVICE_DETECT_ATTEMPTS","androidNeverForLocation","pause","PAUSE"],"sourceRoot":""}