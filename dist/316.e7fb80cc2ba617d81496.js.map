{"version":3,"file":"316.e7fb80cc2ba617d81496.js","mappings":"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","sources":["webpack://mytonwallet/./src/api/common/ledger.ts","webpack://mytonwallet/./src/api/chains/ton/ledger/support.ts","webpack://mytonwallet/./src/util/compareVersions.ts","webpack://mytonwallet/./src/api/chains/ton/ledger/utils.ts","webpack://mytonwallet/./src/api/chains/ton/ledger/other.ts","webpack://mytonwallet/./src/api/chains/ton/ledger/wallet.ts","webpack://mytonwallet/./src/api/chains/ton/ledger/transactions.ts","webpack://mytonwallet/./src/api/chains/ton/ledger/tonConnect.ts"],"sourcesContent":["/*\r\n * This file must be imported dynamically via import().\r\n * This is needed to reduce the app size when Ledger is not used.\r\n */\r\n\r\nimport Transport from '@ledgerhq/hw-transport';\r\n\r\nimport type { ApiLedgerDriver } from '../types';\r\nimport { ApiHardwareError } from '../types';\r\n\r\nimport { IS_AIR_APP } from '../../config';\r\nimport { callWindow } from '../../util/windowProvider/connector';\r\n\r\n/**\r\n * Serialization format differs between web/capacitor and native apps:\r\n *  - Native (AIR) apps: Use hex format (expected by native Ledger library implementations)\r\n *  - Web/Capacitor apps: Use base64 format (more efficient for browser message passing)\r\n */\r\nconst serializationFormat = IS_AIR_APP ? 'hex' : 'base64';\r\n\r\nconst BROKEN_CONNECTION_ERRORS = new Set([\r\n  // This error occurs sometimes if the chains' Ledger app is closed during a data transmission with Ledger\r\n  'DisconnectedDeviceDuringOperation',\r\n  // One way to reproduce this error is:\r\n  // 1. Run the app in Capacitor on iOS,\r\n  // 2. Connect Ledger and open TON App,\r\n  // 3. Start the connection in the UI, e.g. by sending a transaction,\r\n  // 4. As soon as the checklist screen appears, exit TON App immediately,\r\n  // 5. Start the connection in the UI again without entering TON App.\r\n  // It happens only sometimes. The error message suggests reconnecting Ledger.\r\n  'TransportRaceCondition',\r\n]);\r\n\r\n/**\r\n * A Ledger's Transport implementation that passes the data to the actual transfer object in the main browser thread\r\n * (src/util/ledger/index.ts) via postMessage (because actual Ledger transports don't work in worker threads).\r\n */\r\nclass WindowTransport extends Transport {\r\n  /** Use `getDeviceModel()` instead */\r\n  declare deviceModel: never;\r\n\r\n  /** The thrown errors may unexpectedly have the default `Error` class. For reliability, check the `name` instead. */\r\n  async exchange(apdu: Buffer) {\r\n    const response = await callWindow('exchangeWithLedger', apdu.toString(serializationFormat));\r\n    return Buffer.from(response, serializationFormat);\r\n  }\r\n\r\n  getDeviceModel() {\r\n    return callWindow('getLedgerDeviceModel');\r\n  }\r\n}\r\n\r\n/** Connection with Ledger (blockchain-agnostic) */\r\nexport const ledgerTransport = new WindowTransport();\r\n\r\nexport async function getLedgerDeviceInfo() {\r\n  const deviceModel = await ledgerTransport.getDeviceModel();\r\n  const driver: ApiLedgerDriver = 'HID';\r\n\r\n  return {\r\n    driver,\r\n    deviceId: deviceModel?.id,\r\n    deviceName: deviceModel?.productName,\r\n  };\r\n}\r\n\r\nfunction isLedgerConnectionBroken(error: unknown) {\r\n  return error instanceof Error && BROKEN_CONNECTION_ERRORS.has(error.name);\r\n}\r\n\r\n/** Throws unexpected errors (i.e. caused by mistakes in the app code), and returns expected */\r\nexport function handleLedgerCommonError(error: unknown) {\r\n  if (isLedgerConnectionBroken(error)) {\r\n    return { error: ApiHardwareError.ConnectionBroken };\r\n  }\r\n\r\n  throw error;\r\n}\r\n","import type { DeviceModelId } from '@ledgerhq/devices';\r\nimport type { TonPayloadFormat } from '@ton-community/ton-ledger';\r\n\r\nimport compareVersions from '../../../../util/compareVersions';\r\nimport { logDebugError } from '../../../../util/logs';\r\n\r\n// You can use the https://github.com/LedgerHQ/app-ton history as the version support reference.\r\n// Warning! The versions MUST NOT be lower than the actual versions that added support for these features. Otherwise,\r\n// signing that transactions WILL FAIL. If you are not sure, set the version to a higher value. In that case Ledger will\r\n// display the transactions as blind/unknown, but will be able to sign them.\r\n\r\nexport const VERSION_WITH_GET_SETTINGS = '2.1';\r\nexport const VERSION_WITH_WALLET_SPECIFIERS = '2.1';\r\n\r\n/** The values are the TON App versions. The keys are the largest jetton ids (jetton indices) added in that versions. */\r\nconst VERSION_WITH_JETTON_ID = {\r\n  6: '2.2',\r\n  9: '2.6.1',\r\n  10: '2.8.0', // TODO Replace to real version\r\n};\r\n\r\nexport const VERSION_WITH_PAYLOAD: Record<TonPayloadFormat['type'], string> = {\r\n  unsafe: '2.1',\r\n  comment: '0',\r\n  'jetton-transfer': '0',\r\n  'nft-transfer': '2.1',\r\n  'jetton-burn': '2.1',\r\n  'add-whitelist': '2.1',\r\n  'single-nominator-withdraw': '2.1',\r\n  'single-nominator-change-validator': '2.1',\r\n  'tonstakers-deposit': '2.1',\r\n  'vote-for-proposal': '2.1',\r\n  'change-dns-record': '2.1',\r\n  'token-bridge-pay-swap': '2.1',\r\n  'tonwhales-pool-deposit': '2.7',\r\n  'tonwhales-pool-withdraw': '2.7',\r\n  'vesting-send-msg-comment': '2.7',\r\n};\r\n\r\nexport const DEVICES_WITH_LOCK_DOUBLE_CHECK = new Set<`${DeviceModelId}`>(['nanoS', 'nanoSP']);\r\n\r\n// https://github.com/LedgerHQ/app-ton/blob/d3e1edbbc1fcf9a5d6982fbb971f757a83d0aa56/doc/MESSAGES.md?plain=1#L51\r\nconst DEVICES_NOT_SUPPORTING_JETTON_ID = new Set<`${DeviceModelId}`>(['nanoS']);\r\n\r\nexport function doesSupport(ledgerTonVersion: string, featureVersion: string) {\r\n  return compareVersions(ledgerTonVersion, featureVersion) >= 0;\r\n}\r\n\r\n/**\r\n * Checks whether the current Ledger device supports `knownJetton` generally\r\n */\r\nexport function doesSupportKnownJetton(ledgerModel: DeviceModelId | undefined, ledgerTonVersion: string) {\r\n  return ledgerModel // If the Ledger model is unknown, assuming it can be any model and acting safely\r\n    && !DEVICES_NOT_SUPPORTING_JETTON_ID.has(ledgerModel)\r\n    // Note: JavaScript sorts the numeric `VERSION_WITH_JETTON_ID` keys in ascending order automatically\r\n    && doesSupport(ledgerTonVersion, Object.values(VERSION_WITH_JETTON_ID)[0]);\r\n}\r\n\r\n/**\r\n * Checks that the current Ledger device supports the specific jetton id. This function should be used only if\r\n * `doesSupportKnownJetton` returns `true`, because it doesn't check what that function checks.\r\n */\r\nexport function doesSupportKnownJettonId(ledgerTonVersion: string, jettonId: number) {\r\n  // Note: JavaScript sorts the numeric `VERSION_WITH_JETTON_ID` keys in ascending order automatically\r\n  for (const [candidateJettonId, candidateVersion] of Object.entries(VERSION_WITH_JETTON_ID)) {\r\n    if (jettonId <= Number(candidateJettonId)) {\r\n      return doesSupport(ledgerTonVersion, candidateVersion);\r\n    }\r\n  }\r\n\r\n  logDebugError(`The minimum TON App version for jetton id ${jettonId} is not set in VERSION_WITH_JETTON_ID`);\r\n  return false;\r\n}\r\n","export default function compareVersions(versionA: string, versionB: string): -1 | 0 | 1 {\r\n  const partsA = versionA.split('.').map(Number);\r\n  const partsB = versionB.split('.').map(Number);\r\n\r\n  for (let i = 0; i < Math.max(partsA.length, partsB.length); i++) {\r\n    const partA = partsA[i] || 0;\r\n    const partB = partsB[i] || 0;\r\n\r\n    if (partA > partB) return 1;\r\n    if (partA < partB) return -1;\r\n  }\r\n\r\n  return 0;\r\n}\r\n","import { TransportStatusError } from '@ledgerhq/errors';\r\nimport { TonTransport } from '@ton-community/ton-ledger';\r\n\r\nimport type { ApiNetwork, ApiTonWallet } from '../../../types';\r\nimport { ApiHardwareError } from '../../../types';\r\n\r\nimport { handleLedgerCommonError, ledgerTransport } from '../../../common/ledger';\r\nimport { LEDGER_WALLET_VERSIONS, WALLET_IS_BOUNCEABLE, WORKCHAIN, Workchain } from '../constants';\r\n\r\nexport type PossibleWalletVersion = keyof typeof LEDGER_WALLET_VERSIONS;\r\n\r\nexport const tonTransport = new TonTransport(ledgerTransport);\r\n\r\nexport function getLedgerAccountPathByWallet(network: ApiNetwork, wallet: ApiTonWallet, workchain?: Workchain) {\r\n  return getLedgerAccountPathByIndex(wallet.index, network !== 'mainnet', workchain);\r\n}\r\n\r\nexport function getLedgerAccountPathByIndex(index: number, isTestnet: boolean, workchain = WORKCHAIN) {\r\n  const network = isTestnet ? 1 : 0;\r\n  const chain = getInternalWorkchain(workchain);\r\n  return [44, 607, network, chain, index, 0];\r\n}\r\n\r\nfunction getInternalWorkchain(workchain: Workchain) {\r\n  return workchain === Workchain.MasterChain ? 255 : 0;\r\n}\r\n\r\nexport function getInternalWalletVersion(version: PossibleWalletVersion) {\r\n  return LEDGER_WALLET_VERSIONS[version];\r\n}\r\n\r\n/** Throws unexpected errors (i.e. caused by mistakes in the app code), and returns expected */\r\nexport function handleLedgerTonError(error: unknown) {\r\n  if (error instanceof TransportStatusError) {\r\n    // Status code reference: https://github.com/LedgerHQ/app-ton/blob/d3e1edbbc1fcf9a5d6982fbb971f757a83d0aa56/src/sw.h\r\n    switch (error.statusCode) {\r\n      case 0x6985: return { error: ApiHardwareError.RejectedByUser };\r\n      case 0xbd00: return { error: ApiHardwareError.BlindSigningNotEnabled };\r\n      // The limits for Ton Connect proofs are: payload ≤ 128 bytes, domain ≤ 128 bytes, payload + domain ≤ 222 bytes\r\n      case 0xb00b: return { error: ApiHardwareError.ProofTooLarge };\r\n    }\r\n  }\r\n\r\n  return handleLedgerCommonError(error);\r\n}\r\n\r\n/** Checks whether the current Ledger device is the one that stores the given wallet */\r\nexport async function doesLedgerDeviceMatch(network: ApiNetwork, wallet: ApiTonWallet) {\r\n  const { publicKey } = await tonTransport.getAddress(\r\n    ...getLedgerWalletParams(network, wallet.index, wallet.version as PossibleWalletVersion),\r\n  );\r\n  return publicKey.toString('hex') === wallet.publicKey;\r\n}\r\n\r\nexport function getLedgerWalletParams(network: ApiNetwork, accountIndex: number, walletVersion: PossibleWalletVersion) {\r\n  const isTestnet = network !== 'mainnet';\r\n  const workchain = WORKCHAIN;\r\n  const accountPath = getLedgerAccountPathByIndex(accountIndex, isTestnet, workchain);\r\n\r\n  return [accountPath, {\r\n    testOnly: isTestnet,\r\n    chain: getInternalWorkchain(workchain),\r\n    bounceable: WALLET_IS_BOUNCEABLE,\r\n    walletVersion: getInternalWalletVersion(walletVersion),\r\n  }] as const;\r\n}\r\n","import { StatusCodes, TransportStatusError } from '@ledgerhq/errors';\r\n\r\nimport type { ApiHardwareError } from '../../../types';\r\n\r\nimport { ledgerTransport } from '../../../common/ledger';\r\nimport { LEDGER_DEFAULT_WALLET_VERSION } from '../constants';\r\nimport { DEVICES_WITH_LOCK_DOUBLE_CHECK } from './support';\r\nimport { getInternalWalletVersion, getLedgerAccountPathByIndex, handleLedgerTonError, tonTransport } from './utils';\r\n\r\nexport async function isLedgerTonAppOpen(): Promise<boolean | { error: ApiHardwareError }> {\r\n  try {\r\n    if (!(await tonTransport.isAppOpen())) {\r\n      return false;\r\n    }\r\n\r\n    const deviceModel = await ledgerTransport.getDeviceModel();\r\n\r\n    if (!deviceModel || DEVICES_WITH_LOCK_DOUBLE_CHECK.has(deviceModel.id)) {\r\n      // Workaround for Ledger Nano S or Nano S Plus, this is a way to check if it is unlocked.\r\n      // There will be an error with code 0x530c.\r\n      await tonTransport.getAddress(getLedgerAccountPathByIndex(0, false), {\r\n        walletVersion: getInternalWalletVersion(LEDGER_DEFAULT_WALLET_VERSION),\r\n      });\r\n    }\r\n\r\n    return true;\r\n  } catch (err) {\r\n    if (err instanceof TransportStatusError && (\r\n      err.statusCode === StatusCodes.LOCKED_DEVICE\r\n      || err.statusCode === 0x530c\r\n    )) {\r\n      return false;\r\n    }\r\n\r\n    return handleLedgerTonError(err);\r\n  }\r\n}\r\n","import type { ApiHardwareError, ApiNetwork, ApiTonWallet } from '../../../types';\r\n\r\nimport { LEDGER_DEFAULT_WALLET_VERSION } from '../constants';\r\nimport { getLedgerWalletParams, handleLedgerTonError, type PossibleWalletVersion, tonTransport } from './utils';\r\n\r\n/**\r\n * Takes about 170ms on Ledger Nano X connected to Chrome on macOS and 212ms on Ledger Nano X connected to iPhone.\r\n * There is no need to call this function in parallel, because the transport will force them to be sequential anyway.\r\n */\r\nexport async function getLedgerTonWallet(\r\n  network: ApiNetwork,\r\n  accountIndex: number,\r\n): Promise<ApiTonWallet | { error: ApiHardwareError }> {\r\n  try {\r\n    const version = LEDGER_DEFAULT_WALLET_VERSION;\r\n    const { address, publicKey } = await tonTransport.getAddress(\r\n      ...getLedgerWalletParams(network, accountIndex, version),\r\n    );\r\n\r\n    return {\r\n      index: accountIndex,\r\n      address,\r\n      publicKey: publicKey.toString('hex'),\r\n      version,\r\n    };\r\n  } catch (err) {\r\n    return handleLedgerTonError(err);\r\n  }\r\n}\r\n\r\nexport async function verifyLedgerTonAddress(\r\n  network: ApiNetwork,\r\n  wallet: ApiTonWallet,\r\n): Promise<string | { error: ApiHardwareError }> {\r\n  try {\r\n    const { address } = await tonTransport.validateAddress(\r\n      ...getLedgerWalletParams(network, wallet.index, wallet.version as PossibleWalletVersion),\r\n    );\r\n    return address;\r\n  } catch (err) {\r\n    return handleLedgerTonError(err);\r\n  }\r\n}\r\n","import type { DeviceModelId } from '@ledgerhq/devices';\r\nimport type { Address, Cell } from '@ton/core';\r\nimport type { TonPayloadFormat, TonTransport } from '@ton-community/ton-ledger';\r\nimport { KNOWN_JETTONS } from '@ton-community/ton-ledger';\r\nimport { parseMessage } from '@ton-community/ton-ledger';\r\n\r\nimport type { ApiNetwork, ApiTonWallet } from '../../../types';\r\nimport type { ApiTonWalletVersion, PreparedTransactionToSign, TonTransferHints } from '../types';\r\nimport { ApiHardwareError } from '../../../types';\r\n\r\nimport { logDebug, logDebugError } from '../../../../util/logs';\r\nimport { resolveTokenAddress, toBase64Address } from '../util/tonCore';\r\nimport { ledgerTransport } from '../../../common/ledger';\r\nimport { ATTEMPTS, TRANSFER_TIMEOUT_SEC, WORKCHAIN } from '../constants';\r\nimport {\r\n  doesSupport,\r\n  doesSupportKnownJetton,\r\n  doesSupportKnownJettonId,\r\n  VERSION_WITH_GET_SETTINGS,\r\n  VERSION_WITH_PAYLOAD,\r\n  VERSION_WITH_WALLET_SPECIFIERS,\r\n} from './support';\r\nimport { doesLedgerDeviceMatch, getLedgerAccountPathByWallet, handleLedgerTonError, tonTransport } from './utils';\r\n\r\nexport type LedgerTransactionParams = Parameters<TonTransport['signTransaction']>[1];\r\n\r\nexport const knownJettonAddresses = Object.fromEntries(\r\n  KNOWN_JETTONS.map(({ masterAddress }, jettonId) => [\r\n    toBase64Address(masterAddress, true, 'mainnet'),\r\n    jettonId,\r\n  ]),\r\n);\r\n\r\n/** Thrown when and only when the Ledger TON app needs to be updated to support this transaction */\r\nexport const unsupportedError = new Error('Unsupported');\r\n\r\nexport const lacksBlindSigningError = new Error('Lacks blind signing');\r\n\r\n/**\r\n * Signs the given TON transactions using Ledger. Because Ledger can't sign multiple messages at once, each transaction\r\n * must contain exactly 1 message, and the transactions will be signed one by one. If everything is ok, returns the\r\n * signed transactions in the same order as the input transactions.\r\n */\r\nexport async function signTonTransactionsWithLedger(\r\n  network: ApiNetwork,\r\n  wallet: ApiTonWallet,\r\n  tonTransactions: PreparedTransactionToSign[],\r\n  subwalletId?: number,\r\n  maxRetries = ATTEMPTS,\r\n): Promise<Cell[] | { error: ApiHardwareError }> {\r\n  const accountPath = getLedgerAccountPathByWallet(network, wallet);\r\n  let ledgerTransactions: LedgerTransactionParams[];\r\n\r\n  try {\r\n    if (!await doesLedgerDeviceMatch(network, wallet)) {\r\n      return { error: ApiHardwareError.WrongDevice };\r\n    }\r\n\r\n    const deviceModel = await ledgerTransport.getDeviceModel();\r\n    const ledgerTonVersion = await tonTransport.getVersion();\r\n    const isBlindSigningEnabled = await getIsBlindSigningEnabled(ledgerTonVersion);\r\n\r\n    // To improve the UX, making sure all the transactions are signable before asking the user to sign them\r\n    ledgerTransactions = await Promise.all(tonTransactions.map((tonTransaction) => (\r\n      tonTransactionToLedgerTransaction(\r\n        network,\r\n        wallet.version,\r\n        tonTransaction,\r\n        deviceModel?.id,\r\n        ledgerTonVersion,\r\n        isBlindSigningEnabled,\r\n        subwalletId,\r\n      )\r\n    )));\r\n  } catch (err) {\r\n    if (err === unsupportedError) return { error: ApiHardwareError.HardwareOutdated };\r\n    if (err === lacksBlindSigningError) return { error: ApiHardwareError.BlindSigningNotEnabled };\r\n    return handleLedgerTonError(err);\r\n  }\r\n\r\n  return signLedgerTransactionsWithRetry(accountPath, ledgerTransactions, maxRetries);\r\n}\r\n\r\nasync function getIsBlindSigningEnabled(ledgerTonVersion: string) {\r\n  if (!doesSupport(ledgerTonVersion, VERSION_WITH_GET_SETTINGS)) {\r\n    return true; // If Ledger actually doesn't allow blind signing, it will throw an error later\r\n  }\r\n\r\n  const { blindSigningEnabled } = await tonTransport.getSettings();\r\n  return blindSigningEnabled;\r\n}\r\n\r\n/**\r\n * Converts a transaction, that you would pass to `TonWallet.createTransfer`, to the format suitable for Ledger's\r\n * `TonTransport.signTransaction`.\r\n */\r\nexport async function tonTransactionToLedgerTransaction(\r\n  network: ApiNetwork,\r\n  walletVersion: ApiTonWalletVersion,\r\n  tonTransaction: PreparedTransactionToSign,\r\n  ledgerModel: DeviceModelId | undefined,\r\n  ledgerTonVersion: string,\r\n  isBlindSigningEnabled: boolean,\r\n  subwalletId?: number,\r\n): Promise<LedgerTransactionParams> {\r\n  const { authType = 'external', sendMode = 0, seqno, timeout, hints } = tonTransaction;\r\n  const message = getMessageFromTonTransaction(tonTransaction);\r\n\r\n  if (authType !== 'external') {\r\n    throw new Error(`Unsupported transaction authType \"${authType}\"`);\r\n  }\r\n  if (message.info.type !== 'internal') {\r\n    throw new Error(`Unsupported message type \"${message.info.type}\"`);\r\n  }\r\n\r\n  const payload = await getPayload(\r\n    network,\r\n    message.info.dest,\r\n    message.body,\r\n    ledgerModel,\r\n    ledgerTonVersion,\r\n    isBlindSigningEnabled,\r\n    hints,\r\n  );\r\n\r\n  return {\r\n    to: message.info.dest,\r\n    sendMode,\r\n    seqno,\r\n    timeout: timeout ?? getFallbackTimeout(),\r\n    bounce: message.info.bounce,\r\n    amount: message.info.value.coins,\r\n    stateInit: message.init ?? undefined,\r\n    payload,\r\n    walletSpecifiers: getWalletSpecifiers(walletVersion, ledgerTonVersion, subwalletId),\r\n  };\r\n}\r\n\r\nfunction getMessageFromTonTransaction({ messages }: PreparedTransactionToSign) {\r\n  if (messages.length === 0) throw new Error('No messages');\r\n  if (messages.length > 1) throw new Error('Ledger doesn\\'t support signing more than 1 message');\r\n  return messages[0];\r\n}\r\n\r\nfunction getFallbackTimeout() {\r\n  return Math.floor(Date.now() / 1000 + TRANSFER_TIMEOUT_SEC);\r\n}\r\n\r\n/**\r\n * Like `tonPayloadToLedgerPayload`, but also performs long asynchronous operations such as fetching data for the\r\n * `knownJetton` field.\r\n */\r\nasync function getPayload(\r\n  network: ApiNetwork,\r\n  toAddress: Address,\r\n  tonPayload: Cell | undefined,\r\n  ledgerModel: DeviceModelId | undefined,\r\n  ledgerTonVersion: string,\r\n  isBlindSigningEnabled: boolean,\r\n  { tokenAddress }: TonTransferHints = {},\r\n) {\r\n  const ledgerPayload = tonPayloadToLedgerPayload(tonPayload, ledgerTonVersion);\r\n\r\n  if (ledgerPayload?.type === 'jetton-transfer' && doesSupportKnownJetton(ledgerModel, ledgerTonVersion)) {\r\n    if (!tokenAddress) {\r\n      const tokenWalletAddress = toBase64Address(toAddress, true, network);\r\n      tokenAddress = await resolveTokenAddress(network, tokenWalletAddress);\r\n    }\r\n\r\n    if (tokenAddress) {\r\n      ledgerPayload.knownJetton = getKnownJetton(ledgerTonVersion, tokenAddress);\r\n    }\r\n  }\r\n\r\n  if (ledgerPayload?.type === 'unsafe' && !isBlindSigningEnabled) {\r\n    throw lacksBlindSigningError;\r\n  }\r\n\r\n  return ledgerPayload;\r\n}\r\n\r\n/**\r\n * Converts a TON message body to the Ledger payload format. Doesn't populate the `knownJetton` field.\r\n */\r\nexport function tonPayloadToLedgerPayload(tonPayload: Cell | undefined, ledgerTonVersion: string) {\r\n  if (!tonPayload) {\r\n    return undefined;\r\n  }\r\n\r\n  let ledgerPayload: TonPayloadFormat | undefined;\r\n\r\n  try {\r\n    ledgerPayload = parseMessage(tonPayload, {\r\n      disallowUnsafe: true, // Otherwise no error will be thrown, and we won't see why the payload can't be converted\r\n      // We don't use `disallowModification: true`, because it can cause an unnecessary \"unsafe\" payload, for example,\r\n      // when a token is transferred with a short comment. On the other hand, the fee may increase by about 0.0001 TON.\r\n    });\r\n  } catch (err) {\r\n    logDebug('Unsafe Ledger payload', err);\r\n    ledgerPayload = {\r\n      type: 'unsafe',\r\n      message: tonPayload,\r\n    };\r\n  }\r\n\r\n  if (ledgerPayload && !doesSupport(ledgerTonVersion, VERSION_WITH_PAYLOAD[ledgerPayload.type])) {\r\n    logDebug(`The ${ledgerPayload.type} payload type is not supported by Ledger TON v${ledgerTonVersion}`);\r\n    if (!doesSupport(ledgerTonVersion, VERSION_WITH_PAYLOAD.unsafe)) {\r\n      throw unsupportedError;\r\n    }\r\n\r\n    logDebug('Falling back to an unsafe payload');\r\n    ledgerPayload = {\r\n      type: 'unsafe',\r\n      message: tonPayload,\r\n    };\r\n  }\r\n\r\n  return ledgerPayload;\r\n}\r\n\r\nasync function signLedgerTransactionsWithRetry(\r\n  accountPath: number[],\r\n  ledgerTransactions: LedgerTransactionParams[],\r\n  maxRetries: number,\r\n) {\r\n  const signedTransactions: Cell[] = [];\r\n  let retryCount = 0;\r\n  let index = 0;\r\n\r\n  while (index < ledgerTransactions.length) {\r\n    try {\r\n      signedTransactions.push(await tonTransport.signTransaction(accountPath, ledgerTransactions[index]));\r\n      index++;\r\n    } catch (err) {\r\n      try {\r\n        return handleLedgerTonError(err);\r\n      } catch {\r\n        if (retryCount >= maxRetries) {\r\n          throw err;\r\n        }\r\n        retryCount++;\r\n      }\r\n      logDebugError('signLedgerTransactionsWithRetry', err);\r\n    }\r\n  }\r\n\r\n  return signedTransactions;\r\n}\r\n\r\nfunction getKnownJetton(ledgerTonVersion: string, tokenAddress: string) {\r\n  const jettonId = knownJettonAddresses[tokenAddress];\r\n  return jettonId !== undefined && doesSupportKnownJettonId(ledgerTonVersion, jettonId)\r\n    ? { jettonId, workchain: WORKCHAIN }\r\n    : null; // eslint-disable-line no-null/no-null\r\n}\r\n\r\nfunction getWalletSpecifiers(walletVersion: ApiTonWalletVersion, ledgerTonVersion: string, subwalletId?: number) {\r\n  if (walletVersion === 'v3R2') {\r\n    if (!doesSupport(ledgerTonVersion, VERSION_WITH_WALLET_SPECIFIERS)) throw unsupportedError;\r\n    return { includeWalletOp: false };\r\n  }\r\n  if (subwalletId !== undefined) {\r\n    if (!doesSupport(ledgerTonVersion, VERSION_WITH_WALLET_SPECIFIERS)) throw unsupportedError;\r\n    return { subwalletId, includeWalletOp: false };\r\n  }\r\n  return undefined;\r\n}\r\n","import type { ApiTonConnectProof } from '../../../tonConnect/types';\r\nimport type { ApiNetwork, ApiTonWallet } from '../../../types';\r\nimport { ApiHardwareError } from '../../../types';\r\n\r\nimport { doesLedgerDeviceMatch, getLedgerAccountPathByWallet, handleLedgerTonError, tonTransport } from './utils';\r\n\r\nexport async function signTonProofWithLedger(\r\n  network: ApiNetwork,\r\n  wallet: ApiTonWallet,\r\n  proof: ApiTonConnectProof,\r\n): Promise<Buffer | { error: ApiHardwareError }> {\r\n  const accountPath = getLedgerAccountPathByWallet(network, wallet);\r\n  const { timestamp, domain, payload } = proof;\r\n\r\n  try {\r\n    if (!await doesLedgerDeviceMatch(network, wallet)) {\r\n      return { error: ApiHardwareError.WrongDevice };\r\n    }\r\n\r\n    const result = await tonTransport.getAddressProof(accountPath, {\r\n      domain,\r\n      timestamp,\r\n      payload: Buffer.from(payload),\r\n    });\r\n    return result.signature;\r\n  } catch (err) {\r\n    return handleLedgerTonError(err);\r\n  }\r\n}\r\n"],"names":["serializationFormat","IS_AIR_APP","BROKEN_CONNECTION_ERRORS","Set","WindowTransport","Transport","exchange","apdu","response","callWindow","toString","Buffer","from","getDeviceModel","ledgerTransport","async","getLedgerDeviceInfo","deviceModel","driver","deviceId","id","deviceName","productName","handleLedgerCommonError","error","Error","has","name","isLedgerConnectionBroken","ApiHardwareError","ConnectionBroken","VERSION_WITH_GET_SETTINGS","VERSION_WITH_WALLET_SPECIFIERS","VERSION_WITH_JETTON_ID","VERSION_WITH_PAYLOAD","unsafe","comment","DEVICES_WITH_LOCK_DOUBLE_CHECK","DEVICES_NOT_SUPPORTING_JETTON_ID","doesSupport","ledgerTonVersion","featureVersion","versionA","versionB","partsA","split","map","Number","partsB","i","Math","max","length","partA","partB","compareVersions","tonTransport","TonTransport","getLedgerAccountPathByWallet","network","wallet","workchain","getLedgerAccountPathByIndex","index","isTestnet","getInternalWorkchain","arguments","undefined","WORKCHAIN","Workchain","MasterChain","getInternalWalletVersion","version","LEDGER_WALLET_VERSIONS","handleLedgerTonError","TransportStatusError","statusCode","RejectedByUser","BlindSigningNotEnabled","ProofTooLarge","doesLedgerDeviceMatch","publicKey","getAddress","getLedgerWalletParams","accountIndex","walletVersion","testOnly","chain","bounceable","WALLET_IS_BOUNCEABLE","isLedgerTonAppOpen","isAppOpen","LEDGER_DEFAULT_WALLET_VERSION","err","StatusCodes","LOCKED_DEVICE","getLedgerTonWallet","address","verifyLedgerTonAddress","validateAddress","knownJettonAddresses","Object","fromEntries","KNOWN_JETTONS","_ref","jettonId","masterAddress","toBase64Address","unsupportedError","lacksBlindSigningError","signTonTransactionsWithLedger","tonTransactions","subwalletId","maxRetries","ATTEMPTS","accountPath","ledgerTransactions","WrongDevice","getVersion","isBlindSigningEnabled","blindSigningEnabled","getSettings","getIsBlindSigningEnabled","Promise","all","tonTransaction","ledgerModel","authType","sendMode","seqno","timeout","hints","message","_ref2","messages","getMessageFromTonTransaction","info","type","payload","toAddress","tonPayload","tokenAddress","ledgerPayload","parseMessage","disallowUnsafe","logDebug","tonPayloadToLedgerPayload","values","doesSupportKnownJetton","tokenWalletAddress","resolveTokenAddress","knownJetton","candidateJettonId","candidateVersion","entries","logDebugError","doesSupportKnownJettonId","getKnownJetton","getPayload","dest","body","to","floor","Date","now","TRANSFER_TIMEOUT_SEC","bounce","amount","value","coins","stateInit","init","walletSpecifiers","getWalletSpecifiers","tonTransactionToLedgerTransaction","HardwareOutdated","signedTransactions","retryCount","push","signTransaction","signLedgerTransactionsWithRetry","includeWalletOp","signTonProofWithLedger","proof","timestamp","domain","getAddressProof","signature"],"sourceRoot":""}