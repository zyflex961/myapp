"use strict";(self.webpackChunkmytonwallet=self.webpackChunkmytonwallet||[]).push([[642],{17642:(e,t,i)=>{i.d(t,{BleConnector:()=>te});var n=i(12757),r=i(54011),c=i(31481),o=i(71108),a=i(17276),s=i(15123),d=i(24450),u=i(13983),l=i(13648),h=i(72985),w=i(44240),v=i(9162),f=i(72316),p=i(37968),g=i(62467),y=i(13288),m=i(59099),T=i(66847),b=i(69850),E=i(81160),C=i(65277),D=i(8767),x=i(1005),I=i(93776),k=i(48287).Buffer;const S=e=>e&&e.message&&(e.message.includes("was disconnected")||e.message.includes("not found"))?new d.DisconnectedDevice:e,F=e=>{throw e??new Error};var M=i(48287).Buffer;const P="ble-verbose",L={pairingThreshold:1e3,delayAfterFirstPairing:4e3},U={},B={},O={requestMTU:156,connectionPriority:1},A=(e,t)=>{const i=B[e];i&&i.disconnectTimeout&&((0,l.trace)({type:P,message:"Clearing queued disconnect",context:t}),clearTimeout(i.disconnectTimeout))};let N;class R extends u.Ay{static disconnectTimeoutMs=5e3;static list=()=>{throw new Error("not implemented")};static listen(e){let t=!1;return new l.LocalTracer(P).trace("Listening for devices ..."),n.Fk.getConnectedDevices((0,o.gq)()).then(async i=>{if(!t){for(const t of i)e.next({type:"add",device:t});await n.Fk.stopLEScan(),n.Fk.requestLEScan({services:(0,o.gq)()},i=>{t||e.next({type:"add",device:i.device})})}}),{unsubscribe:async()=>{t=!0,await n.Fk.stopLEScan()}}}static async open(e,t,i){let{rxjsScheduler:n}=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return $(e,!0,t,i,{rxjsScheduler:n})}static disconnectDevice=async(e,t,i)=>{const r=new l.LocalTracer(P,i);r.trace(`Trying to disconnect device ${e}`);try{await n.Fk.disconnect(e),null==t||t()}catch(e){r.withType("ble-error").trace("Error while trying to cancel device connection",{error:e})}r.trace(`Device ${e} disconnected`)};device;deviceModel;disconnectTimeout=null;id;isConnected=!0;mtuSize=20;notifyObservable;notYetDisconnected=!0;writableWithResponseCharacteristic;writableWithoutResponseCharacteristic;rxjsScheduler;currentTransactionIds;onDisconnect;disconnectCallback;constructor(e,t,i,n,r){let{context:c,rxjsScheduler:o}=arguments.length>5&&void 0!==arguments[5]?arguments[5]:{};super({context:c,logType:P}),this.id=e.deviceId,this.device=e,this.writableWithResponseCharacteristic=t,this.writableWithoutResponseCharacteristic=i,this.notifyObservable=n,this.deviceModel=r,this.rxjsScheduler=o,this.currentTransactionIds=[],A(this.id),this.tracer.trace(`New instance of BleTransport for device ${this.id}`)}exchange=(()=>{var e=this;return function(t){let{abortTimeoutMs:i}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};e.exchangeBusyPromise&&R.disconnectDevice(e.id,e.onDisconnect);const n=e.tracer.withUpdatedContext({function:"exchange"});return n.trace("Exchanging APDU ...",{abortTimeoutMs:i}),n.withType("apdu").trace(`=> ${t.toString("hex")}`),e.exchangeAtomicImpl(()=>(0,h._)((0,w.h)(e.notifyObservable.pipe(e=>(0,a.m)(e,{context:n.getContext()})),(0,s.sendAPDU)(e.write,t,e.mtuSize,{context:n.getContext()})).pipe(i?(0,v.w)(i,e.rxjsScheduler):(0,m.M)(),(0,m.M)(e=>{n.withType("apdu").trace(`<= ${e.toString("hex")}`)}),(0,T.W)(async t=>{if(t instanceof v.M)throw n.trace("Aborting due to timeout and trying to cancel all communication write of the current exchange",{abortTimeoutMs:i,transactionIds:e.currentTransactionIds}),await e.cancelPendingOperations(),new d.TransportExchangeTimeoutError("Exchange aborted due to timeout");n.withType("ble-error").trace("Error while exchanging APDU",{error:t}),e.notYetDisconnected&&await R.disconnectDevice(e.id,e.onDisconnect);const r=S(t);throw n.trace("Error while exchanging APDU, mapped and throws following error",{mappedError:r}),r}),(0,b.j)(()=>{n.trace("Clearing current transaction ids",{currentTransactionIds:e.currentTransactionIds}),e.clearCurrentTransactionIds()}))))}})();async cancelPendingOperations(){await R.disconnectDevice(this.id,this.onDisconnect)}clearCurrentTransactionIds(){this.currentTransactionIds=[]}async inferMTU(){let e=await n.Fk.getMtu(this.device.deviceId);return this.tracer.trace("Inferring MTU ...",{currentDeviceMtu:e}),await this.exchangeAtomicImpl(async()=>{try{e=await(0,h._)((0,w.h)(this.notifyObservable.pipe((0,E.T)(e=>{if(e instanceof Error)throw e;return e}),(0,C.$)(e=>8===e.readUInt8(0)),(0,E.T)(e=>e.readUInt8(5))),(0,f.v)(()=>(0,p.H)(this.write(M.from([8,0,0,0,0])))).pipe((0,D.w)())))}catch(t){this.tracer.withType("ble-error").trace("Error while inferring MTU",{mtu:e}),await R.disconnectDevice(this.id,this.onDisconnect);const i=S(t);throw this.tracer.trace("Error while inferring APDU, mapped and throws following error",{mappedError:i}),i}finally{this.clearCurrentTransactionIds()}}),this.tracer.trace("Successfully negotiated MTU with device",{mtu:e,mtuSize:this.mtuSize}),e>20&&(this.mtuSize=e),this.mtuSize}async requestConnectionPriority(e){let t;switch(e){case"High":case"Balanced":t=n.rj.CONNECTION_PRIORITY_BALANCED;break;case"LowPower":t=n.rj.CONNECTION_PRIORITY_LOW_POWER}var i;await(i=n.Fk.requestConnectionPriority(this.device.deviceId,t),i.catch(F))}write=async e=>{const t=(0,r.A)();this.currentTransactionIds.push(t);const i=this.tracer.withUpdatedContext({transactionId:t});i.trace("Writing to device",{willMessageBeAcked:!this.writableWithoutResponseCharacteristic});try{const t=new Uint8Array(e),r=new DataView(t.buffer,t.byteOffset,t.byteLength);await n.Fk.write(this.device.deviceId,N,this.writableWithResponseCharacteristic.uuid,r),i.withType("ble-frame").trace(`=> ${e.toString("hex")}`)}catch(e){throw i.trace("Error while writing APDU",{error:e}),new d.DisconnectedDeviceDuringOperation(e instanceof Error?e.message:`${String(e)}`)}};async close(){const e=this.tracer.withUpdatedContext({function:"close"});let t;e.trace("Closing, queuing a disconnect with a timeout ...");const i=new Promise(e=>{t=e});A(this.id),this.disconnectTimeout=setTimeout(()=>{e.trace("Disconnect timeout has been reached ..."),this.isConnected?R.disconnectDevice(this.id,this.onDisconnect,e.getContext()).catch(()=>{}).finally(t):t()},R.disconnectTimeoutMs),await Promise.race([this.exchangeBusyPromise||Promise.resolve(),i])}}async function $(e,t,i,r){let{rxjsScheduler:c}=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{};const a=new l.LocalTracer(P,r);let s,u,h;if(a.trace(`Opening ${"string"==typeof e?e:e.deviceId}`,{needsReconnect:t}),"string"==typeof e){if(u=e,B[e])return a.trace("Transport in cache, using it"),A(e),B[e].setTraceContext(r),B[e];a.trace(`Trying to open device: ${e}`),await async function(){if(await n.gq.initialize(),!await n.gq.isEnabled())throw new d.BluetoothRequired("",{state:"disable"})}();const t=await n.Fk.getDevices([e]);if(a.trace(`Found ${t.length} already known device(s) with given id`,{deviceOrId:e}),[s]=t,!s){const t=(await n.Fk.getServices(e)).map(e=>e.uuid),i=(await n.Fk.getConnectedDevices(t)).filter(t=>t.deviceId===e);a.trace(`No known device with given id.\n        Found ${i.length} devices from already connected devices`,{deviceOrId:e}),[s]=i}if(!s){a.trace("No known nor connected devices with given id. Trying to connect to device",{deviceOrId:e,timeoutMs:i});try{await n.Fk.connect(e,()=>{var e,t;null===(e=(t=h).onDisconnect)||void 0===e||e.call(t)},{timeout:i})}catch(e){throw a.trace(`Error code: ${e.errorCode}`),e}}if(!s)throw new d.CantOpenDevice}else s=e,u=e.deviceId;if(!(await n.Fk.getConnectedDevices((0,o.gq)())).find(e=>e.deviceId===u)){a.trace("Device found but not connected. connecting...",{timeoutMs:i,connectOptions:O});try{await n.Fk.connect(u,()=>{var e,t;null===(e=(t=h).onDisconnect)||void 0===e||e.call(t)},{timeout:i})}catch(e){throw a.trace("Connect error",{error:e}),S(e)}}a.trace("Device is connected now, getting services and characteristics");let w=[];await n.Fk.discoverServices(u),w=await n.Fk.getServices(u);let v=function(e){if(!e||!e.uuids)return;const[t]=e.uuids;if(!t)return;const i=(0,o.R6)(t);return i?(U[e.deviceId]=i,i):void 0}(s);const f=[];if(!v)for(const e of(0,o.gq)())try{const t=w.find(t=>t.uuid===e);if(v=(0,o.R6)(e),v&&t){f.push(...t.characteristics),N=v.serviceUuid;break}}catch(e){}if(!v)throw a.trace("Service not found"),new d.TransportError("service not found","BLEServiceNotFound");const{deviceModel:p,writeUuid:b,writeCmdUuid:E,notifyUuid:C}=v;if(!f)throw a.trace("Characteristics not found"),new d.TransportError("service not found","BLEServiceNotFound");let D,F,M;for(const e of f)e.uuid===b?D=e:e.uuid===E?F=e:e.uuid===C&&(M=e);if(!D)throw new d.TransportError("write characteristic not found","BLECharacteristicNotFound");if(!M)throw new d.TransportError("notify characteristic not found","BLECharacteristicNotFound");if(!D.properties.write)throw new d.TransportError("The writable-with-response characteristic is not writable with response","BLECharacteristicInvalid");if(!M.properties.notify)throw new d.TransportError("notify characteristic not notifiable","BLECharacteristicInvalid");if(F&&!F.properties.writeWithoutResponse)throw new d.TransportError("The writable-without-response characteristic is not writable without response","BLECharacteristicInvalid");const q=await n.Fk.getMtu(s.deviceId);a.trace(`device.mtu=${q}`);const z=((e,t,i,r)=>new I.c(c=>(new l.LocalTracer("ble-verbose",r).trace("Start monitoring BLE characteristics",{characteristicUuid:i.uuid}),n.Fk.startNotifications(e,t,i.uuid,e=>{const t=new Uint8Array(e.buffer),i=k.from(t);c.next(i)}),()=>{n.Fk.stopEnabledNotifications()})))(u,N,M,r).pipe((0,T.W)(e=>{const t=String(e);return t.includes("notify change failed")?(0,g.of)(new d.PairingFailed(t)):(0,y.$)(()=>e)}),(0,m.M)(e=>{e instanceof d.PairingFailed||(0,l.trace)({type:"ble-frame",message:`<= ${e.toString("hex")}`,context:r})}),(0,x.u)()),W=z.subscribe();h=new R(s,D,F,z,p,{context:r,rxjsScheduler:c}),a.trace("New BleTransport created"),h.onDisconnect=e=>{var t,i;h.isConnected=!1,h.notYetDisconnected=!1,W.unsubscribe(),A(h.id),delete B[h.id],a.trace(`On device disconnected callback: cleared cached transport for ${h.id},\n      emitting Transport event "disconnect. Error: ${e}"`,{reason:e}),h.emit("disconnect",e),null===(t=(i=h).disconnectCallback)||void 0===t||t.call(i)},B[h.id]=h;const j=Date.now();try{await h.inferMTU()}finally{const e=Date.now();L?(e-j<L.pairingThreshold?t=!1:p.id===o.Dp.stax&&(a.trace('Skipping "needsReconnect" strategy for Stax'),t=!1),t&&(a.trace("Device needs reconnection. Triggering a disconnect"),await R.disconnectDevice(h.id,h.onDisconnect),await(_=L.delayAfterFirstPairing,new Promise(e=>setTimeout(e,_))))):t=!1}var _;return t?(a.trace("Reconnecting"),$(s,!1,i,r)):h}var q=i(55029),z=i(37836),W=i(82393),j=i(32693);let _,Y,H,J,Q=!1,V=[];function Z(){return!!Y}function G(e){return!!V.find(t=>t.identifier===e.identifier)&&!H}async function K(e){try{if(!G(e))return;const t=await R.open(e.device);if(!G(e))return;const i={device:e.device,bleTransport:t};H=i,t.disconnectCallback=()=>{H=void 0,Z()&&(ee(),X())},setTimeout(()=>{var e,t;(null===(e=H)||void 0===e?void 0:e.device.deviceId)===i.device.deviceId?(null===(t=J)||void 0===t||t(i),ee()):Z()&&(H=void 0,ee(),X())},1e3)}catch(t){setTimeout(()=>{K(e)},1e4)}}async function X(){await ie(),Y=R.listen({next:e=>{if("add"===e.type&&e.device){if(!e.device.name)return;if(V.find(t=>{var i;return t.device.deviceId===(null===(i=e.device)||void 0===i?void 0:i.deviceId)}))return;const t={identifier:(0,r.A)(),device:e.device};V.push(t),K(t)}},error:()=>{ee()},complete:()=>{ee()}})}function ee(){var e;V=[],null===(e=Y)||void 0===e||e.unsubscribe(),Y=void 0}const te={isSupported:async function(){if(!c.UMQ)return!1;let e=!1;try{await ie(),W.Ni&&await n.Fk.requestEnable(),e=await n.Fk.isEnabled(),(0,q.MD)("BLE isSupported result",{isEnabled:e})}catch(e){(0,q.SJ)("Error while checking BLE availability",e)}return e},connect:function(){return new Promise(e=>{J=e,H?J(H):Z()||X()})},stop:ee,openSettings:async function(){W.Ni?await n.Fk.openBluetoothSettings():W.pz&&await n.Fk.openAppSettings()}};async function ie(){if(!Q)return _||(_=(async()=>{let e,t=0;for(;t<j.eZ&&!Q;){try{return await n.Fk.initialize({androidNeverForLocation:!0}),void(Q=!0)}catch(i){e=i,(0,q.SJ)("BLE initialize attempt failed",i),await(0,z.v7)(j.Hz*t)}t+=1}if(!Q)throw e??new Error("BLE initialize failed")})().finally(()=>{_=void 0}),_)}}}]);
//# sourceMappingURL=642.72a7b14cb4f2b49d3145.js.map